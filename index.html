

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Quad808 â€” Quad Interactive Mix Fader</title>

  <style>
    @import url("https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap");
  </style>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: transparent;
      overscroll-behavior: none;
    }

    body {
      -webkit-text-size-adjust: 100%;
      font-family: "Space Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }

    .stage {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px 16px;
      box-sizing: border-box;
      background: transparent;
    }

    .panel {
      width: min(920px, 96vw);
      border-radius: 22px;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 18px 50px rgba(0,0,0,0.55);
      padding: 26px 26px 22px;
      box-sizing: border-box;
      color: #fff;
      position: relative;
      overflow: visible; /* allow FX beyond bounds */
    }

    /* Panel-wide FX overlay so explosions never clip */
    .panelFx {
      position: absolute;
      inset: -40px;            /* extra room so particles can fly */
      pointer-events: none;
      z-index: 3;              /* above labels so nothing clips it */
    }

    /* Reward flash wave overlay */
    .rewardWave {
      position: absolute;
      inset: -10px;
      pointer-events: none;
      z-index: 4;
      opacity: 0;
      mix-blend-mode: screen;
    }
    .rewardWave.run {
      animation: waveFlash 520ms ease-out forwards;
    }
    @keyframes waveFlash {
      0%   { opacity: 0; transform: translateX(18%); }
      10%  { opacity: 1; }
      100% { opacity: 0; transform: translateX(-22%); }
    }
    .rewardWave::before{
      content:"";
      position:absolute;
      inset:-20px;
      background:
        radial-gradient(120px 120px at 88% 35%, rgba(255,255,255,0.95), rgba(255,255,255,0) 60%),
        radial-gradient(180px 180px at 86% 62%, rgba(255,255,255,0.85), rgba(255,255,255,0) 70%),
        linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.55) 50%, rgba(255,255,255,0) 100%);
      filter: blur(2px);
    }

    :root{
      --text: clamp(16px, 2.2vw, 22px);
      --label: clamp(14px, 2.0vw, 20px);
      --trackH: 4px;
      --knob: clamp(28px, 4.0vw, 38px);
      --knobPress: 1.40; /* expand 40% on press */
      --rowGap: clamp(14px, 2.2vw, 18px);
      --labelGap: 10px;
      --hitH: clamp(56px, 9.5vw, 74px);
      --btnH: clamp(44px, 6vw, 54px);
      --btnW: clamp(120px, 18vw, 170px);

      /* end padding so mobile can still "pull past" without leaving screen */
      --endPad: clamp(18px, 3.2vw, 26px);
    }

    .rows {
      display: grid;
      gap: calc(var(--rowGap) * 1.2);
      position: relative;
      z-index: 2;
    }

    .row {
      display: grid;
      grid-template-rows: auto auto;
      gap: var(--labelGap);
    }

    .labels {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: var(--label);
      letter-spacing: 0.20em;
      text-transform: uppercase;
      color: #fff;
      opacity: 0.98;
      padding: 0 2px;
      pointer-events: none;
      position: relative;
      z-index: 2;
    }

    .trackWrap {
      position: relative;
      height: var(--hitH);
      display: flex;
      align-items: center;
      touch-action: none;
      padding-left: var(--endPad);
      padding-right: var(--endPad);
      box-sizing: border-box;
      overflow: visible;
      z-index: 2;
    }

    .track {
      width: 100%;
      height: var(--trackH);
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      position: relative;
      overflow: visible;
    }

    .trackGlow {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(255,255,255,0.95);
      opacity: 0;
      filter: blur(0.4px);
      box-shadow: 0 0 14px rgba(255,255,255,0.35);
      pointer-events: none;
      transition: opacity 70ms linear;
    }

    .knob {
      position: absolute;
      left: 0%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: var(--knob);
      height: var(--knob);
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      will-change: transform, left, top;
      touch-action: none;
      z-index: 5;
    }

    .knob.isDown {
      transform: translate(-50%, -50%) scale(var(--knobPress));
      box-shadow: 0 10px 22px rgba(0,0,0,0.42);
    }

    @media (hover:hover){
      .trackWrap { cursor: grab; }
      .trackWrap:active { cursor: grabbing; }
    }

    .controls {
      display: flex;
      justify-content: center;
      padding-top: 18px;
      position: relative;
      z-index: 2;
    }

    .btn {
      height: var(--btnH);
      width: var(--btnW);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: var(--text);
      letter-spacing: 0.22em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      font-family: inherit;
    }

    .btn:active {
      transform: scale(1.03);
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.28);
    }

    /* Easter egg popup */
    .coupon {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 6;
      background: rgba(0,0,0,0.72);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 16px;
      padding: 16px 18px;
      min-width: min(320px, 86vw);
      text-align: center;
      opacity: 0;
      pointer-events: none;
      box-shadow: 0 18px 48px rgba(0,0,0,0.55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .coupon.show {
      opacity: 1;
      pointer-events: auto;
      animation: popIn 220ms ease-out;
    }
    @keyframes popIn {
      from { transform: translate(-50%, -50%) scale(0.92); opacity: 0; }
      to   { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    .coupon .title {
      font-size: clamp(16px, 2.4vw, 20px);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      margin-bottom: 10px;
    }
    .coupon .code {
      font-size: clamp(18px, 2.8vw, 24px);
      letter-spacing: 0.22em;
      font-weight: 700;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      display: inline-block;
      margin-bottom: 10px;
    }
    .coupon .sub {
      font-size: clamp(12px, 1.8vw, 14px);
      opacity: 0.85;
      letter-spacing: 0.06em;
    }

    @media (max-width: 520px){
      .panel{
        padding: 18px 16px 16px;
        border-radius: 18px;
      }
      .controls{ padding-top: 14px; }
    }
  </style>
</head>

<body>
  <div class="stage">
    <div class="panel" id="panel">
      <canvas class="panelFx" id="panelFx"></canvas>
      <div class="rewardWave" id="rewardWave"></div>

      <div class="coupon" id="coupon">
        <div class="title">Easter Egg Unlocked</div>
        <div class="code" id="couponCode">QUAD50</div>
        <div class="sub">50% off your first order</div>
      </div>

      <div class="rows">
        <div class="row" data-slider="tone">
          <div class="labels">
            <div>RAW</div>
            <div>MIXED</div>
          </div>

          <div class="trackWrap" id="wrapTone" aria-label="Raw Mixed Slider">
            <div class="track">
              <div class="trackGlow" id="glowTone"></div>
            </div>
            <div class="knob" id="knobTone" role="slider" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0"></div>
          </div>
        </div>

        <div class="row" data-slider="blend">
          <div class="labels">
            <div>VOCALS</div>
            <div>BEAT</div>
          </div>

          <div class="trackWrap" id="wrapBlend" aria-label="Vocals Beat Slider">
            <div class="track">
              <div class="trackGlow" id="glowBlend"></div>
            </div>
            <div class="knob" id="knobBlend" role="slider" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0"></div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="btnPlay">PLAY</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   AUDIO
========================= */

const FILES = {
  rawVocals: "assets/audio/RAW_VOCALS.wav",
  quadVocals: "assets/audio/QUAD_VOCALS.wav",
  rawFull: "assets/audio/RAW_VOCALS_BEAT.wav",
  quadFull: "assets/audio/QUAD_VOCALS_BEAT.wav",
};

let audio = {
  ctx: null,
  buffers: {},
  sources: {},
  gains: {},
  started: false,
  playing: false,
  loading: false,
};

async function initAudio() {
  if (audio.ctx) return;
  const Ctx = window.AudioContext || window.webkitAudioContext;
  audio.ctx = new Ctx();
  // iOS: resume must happen on a user gesture; we call resume from pointer handlers too.
  await audio.ctx.resume();
}

async function loadBuffers() {
  if (audio.loading || Object.keys(audio.buffers).length) return;
  audio.loading = true;
  for (const [key, filename] of Object.entries(FILES)) {
    const res = await fetch(filename, { cache: "no-store" });
    if (!res.ok) throw new Error(`Missing file: ${filename}`);
    const arr = await res.arrayBuffer();
    audio.buffers[key] = await audio.ctx.decodeAudioData(arr);
  }
  audio.loading = false;
}

function buildGraph() {
  const make = (name, bufKey) => {
    const src = audio.ctx.createBufferSource();
    src.buffer = audio.buffers[bufKey];
    src.loop = true;
    const gain = audio.ctx.createGain();
    gain.gain.value = 0;
    src.connect(gain).connect(audio.ctx.destination);
    audio.sources[name] = src;
    audio.gains[name] = gain;
  };

  make("rawVocals", "rawVocals");
  make("quadVocals", "quadVocals");
  make("rawFull", "rawFull");
  make("quadFull", "quadFull");

  const t0 = audio.ctx.currentTime + 0.02;
  Object.values(audio.sources).forEach(s => s.start(t0));
}

function setMix(tone, blend) {
  tone = Math.min(1, Math.max(0, tone));
  blend = Math.min(1, Math.max(0, blend));

  const vocalsLayer = (1 - blend);
  const fullLayer = blend;
  const rawPart = (1 - tone);
  const quadPart = tone;

  const now = audio.ctx ? audio.ctx.currentTime : 0;
  const ramp = 0.03;

  const setGain = (node, value) => {
    node.gain.cancelScheduledValues(now);
    node.gain.setTargetAtTime(value, now, ramp);
  };

  if (!audio.gains.rawVocals) return;

  setGain(audio.gains.rawVocals, vocalsLayer * rawPart);
  setGain(audio.gains.quadVocals, vocalsLayer * quadPart);
  setGain(audio.gains.rawFull, fullLayer   * rawPart);
  setGain(audio.gains.quadFull, fullLayer  * quadPart);
}

async function ensureStarted() {
  if (audio.started) return;
  await initAudio();
  await loadBuffers();
  buildGraph();
  audio.started = true;
  audio.playing = true;
}

async function play() {
  await ensureStarted();
  await audio.ctx.resume();
  audio.playing = true;
  updatePlayButton();
}

async function pause() {
  if (!audio.ctx) return;
  await audio.ctx.suspend();
  audio.playing = false;
  updatePlayButton();
}

function updatePlayButton() {
  const btn = document.getElementById("btnPlay");
  btn.textContent = audio.playing ? "PAUSE" : "PLAY";
}

/* =========================
   PANEL-WIDE FX (not clipped)
========================= */

function makePanelFx(canvas, panelEl) {
  const ctx = canvas.getContext("2d");
  const fx = {
    rain: null,        // {parts:[]}
    burst: null,       // {parts:[]}
    rainbow: null,     // {t, dir, strength, y}
    wave: null,        // {t, x0, y0}
  };

  function resize() {
    const r = panelEl.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor((r.width + 80) * dpr);
    canvas.height = Math.floor((r.height + 80) * dpr);
    canvas.style.width = (r.width + 80) + "px";
    canvas.style.height = (r.height + 80) + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  const ro = new ResizeObserver(resize);
  ro.observe(panelEl);
  resize();

  function extravagantBurst(x, y, strength=1) {
    const n = Math.floor(50 + 80 * strength);
    const parts = [];
    for (let i=0;i<n;i++){
      const a = Math.random() * Math.PI * 2;
      const sp = (3.2 + 8.5 * strength) * (0.6 + Math.random()*0.9);
      parts.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        life: 1,
        size: 1.8 + Math.random()*2.8,
        hue: (Math.random()*360)|0
      });
    }
    fx.burst = { parts };
  }

  function startRainbowSweep(y, dir, strength) {
    fx.rainbow = { t: 0, dir, strength: Math.min(1, Math.max(0.2, strength)), y };
  }

  function startRain() {
    const parts = [];
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const n = 160;
    for (let i=0;i<n;i++){
      parts.push({
        x: Math.random()*w,
        y: -20 - Math.random()*h*0.25,
        vy: 3.5 + Math.random()*5.5,
        life: 1,
        size: 1.5 + Math.random()*2.2
      });
    }
    fx.rain = { parts };
  }

  function draw(dt) {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // Rainbow sweep line effect (visual-only)
    if (fx.rainbow) {
      fx.rainbow.t += dt;
      const speed = 1.4 + 1.6 * fx.rainbow.strength;
      const p = (fx.rainbow.t * speed) % 1;
      const xCenter = fx.rainbow.dir === 1 ? (p*w) : ((1-p)*w);

      const grad = ctx.createLinearGradient(xCenter - 220, 0, xCenter + 220, 0);
      for (let i=0;i<=6;i++){
        grad.addColorStop(i/6, `hsla(${(i*60 + fx.rainbow.t*260)%360}, 95%, 62%, ${0.58*fx.rainbow.strength})`);
      }
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.lineCap = "round";
      ctx.lineWidth = 14;
      ctx.strokeStyle = grad;
      ctx.shadowColor = "rgba(255,255,255,0.25)";
      ctx.shadowBlur = 14;
      ctx.beginPath();
      ctx.moveTo(-20, fx.rainbow.y);
      ctx.lineTo(w+20, fx.rainbow.y);
      ctx.stroke();
      ctx.restore();

      // fade out automatically
      if (fx.rainbow.t > 0.65) fx.rainbow = null;
    }

    // Burst particles
    if (fx.burst) {
      const parts = fx.burst.parts;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      for (const pt of parts) {
        pt.x += pt.vx;
        pt.y += pt.vy;
        pt.vx *= 0.93;
        pt.vy *= 0.93;
        pt.life -= 0.020;

        if (pt.life > 0) {
          ctx.fillStyle = `hsla(${pt.hue}, 95%, 62%, ${Math.max(0, pt.life)})`;
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
      fx.burst.parts = parts.filter(p => p.life > 0);
      if (fx.burst.parts.length === 0) fx.burst = null;
    }

    // Rain
    if (fx.rain) {
      const parts = fx.rain.parts;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      for (const p of parts) {
        p.y += p.vy;
        p.vy *= 1.01;
        p.life -= 0.010;

        if (p.life > 0) {
          ctx.globalAlpha = Math.max(0, p.life);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
      fx.rain.parts = parts.filter(p => p.life > 0 && p.y < h + 40);
      if (fx.rain.parts.length === 0) fx.rain = null;
    }
  }

  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    draw(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  return {
    extravagantBurst,
    startRainbowSweep,
    startRain,
  };
}

/* =========================
   REWARD WAVE
========================= */

const rewardWaveEl = document.getElementById("rewardWave");
let rewardArmed = true;

function runRewardWave(){
  if (!rewardArmed) return;
  rewardArmed = false;
  rewardWaveEl.classList.remove("run");
  // reflow
  void rewardWaveEl.offsetWidth;
  rewardWaveEl.classList.add("run");
  setTimeout(() => {
    rewardArmed = true; // can trigger again if they leave and re-enter
  }, 900);
}

/* =========================
   EASTER EGG (bottom knob vertical pull ONLY when both right)
========================= */

const couponEl = document.getElementById("coupon");
const couponCodeEl = document.getElementById("couponCode");
const COUPON_CODE = "QUAD50";

function showCoupon(){
  couponCodeEl.textContent = COUPON_CODE;
  couponEl.classList.add("show");
  // auto-hide after a bit
  setTimeout(() => couponEl.classList.remove("show"), 6500);
}

/* =========================
   SLIDER ENGINE
========================= */

function makeSlider(opts){
  const wrap = opts.wrap;
  const knob = opts.knob;
  const glow = opts.glow;

  let value = opts.initial ?? 0;
  let target = value;
  let display = value;

  let isDown = false;
  let pointerId = null;

  let lastDisplay = display;
  let glowLevel = 0;

  let canSlingshot = false;
  let slingshotEdge = null;
  let dragStartTime = 0;

  let lastSettleTime = performance.now();

  // vertical easter egg state (bottom slider only)
  let vPullEnabled = !!opts.verticalEgg;
  let vPulling = false;
  let vStartY = 0;
  let vOffset = 0;

  // Overpull clamp: knob always visible, hard stop holdable
  const OVERPULL_MAX = 0.34; // allow bigger than before but not infinite

  function trackRect(){
    // track area is wrap inner content after padding
    const r = wrap.getBoundingClientRect();
    const cs = getComputedStyle(wrap);
    const pl = parseFloat(cs.paddingLeft) || 0;
    const pr = parseFloat(cs.paddingRight) || 0;
    return { r, pl, pr, w: Math.max(1, r.width - pl - pr) };
  }

  function pxToValue(px){
    const { r, pl, w } = trackRect();
    const x = px - r.left - pl;
    return x / w;
  }

  function setKnobFromDisplay(){
    const { r, pl, w } = trackRect();

    // keep knob visible: clamp visual position to [-OVERPULL_MAX, 1+OVERPULL_MAX]
    const d = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));

    // compute pixel position along track, then clamp within a hard stop range that stays on screen
    // hard stop distance is inside wrap because we have end padding.
    const x = pl + (d * w);
    const xMin = pl + (-OVERPULL_MAX * w);
    const xMax = pl + ((1+OVERPULL_MAX) * w);

    // convert to % of wrap width
    const xClamped = Math.max(xMin, Math.min(xMax, x));
    const pct = (xClamped / r.width) * 100;

    knob.style.left = pct + "%";
    knob.style.top = "50%";
    knob.style.transform = `translate(-50%, -50%)${knob.classList.contains("isDown") ? " scale(var(--knobPress))" : ""}`;

    knob.setAttribute("aria-valuenow", String(Math.max(0, Math.min(1, value))));
  }

  function rubber(v){
    // keep rubber subtle; beyond ends compress
    if (v < 0) return v * 0.42;
    if (v > 1) return 1 + (v - 1) * 0.42;
    return v;
  }

  function settleSpring(to){
    const from = display;
    const start = performance.now();
    const dur = 260;

    function easeOutBack(t){
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    }

    function tick(now){
      const t = Math.min(1, (now - start) / dur);
      const eased = easeOutBack(t);
      display = from + (to - from) * eased;
      display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
      setKnobFromDisplay();
      if (t < 1) requestAnimationFrame(tick);
      else {
        display = to;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
      }
    }
    requestAnimationFrame(tick);
  }

  function pulledAmount(){
    const d = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
    if (slingshotEdge === "left")  return Math.max(0, -d);
    if (slingshotEdge === "right") return Math.max(0, d - 1);
    return 0;
  }

  function maybeSlingshotRelease(){
    if (!canSlingshot || !slingshotEdge) return false;

    const pulled = pulledAmount();
    const dt = performance.now() - dragStartTime;

    // Mobile: much easier to trigger.
    const PULL_THRESHOLD = 0.030;
    const TOO_SLOW_MS = 1800;

    if (pulled < PULL_THRESHOLD) return false;
    if (dt > TOO_SLOW_MS) return false;

    const strength = Math.min(1.0, pulled / 0.12);
    const dest = (slingshotEdge === "left") ? 1 : 0;
    const dir = (dest === 1) ? 1 : -1;

    opts.onSlingshot?.({ strength, dir, wrap, knob });

    const from = display;
    const start = performance.now();
    const dur = 235 - (strength * 55);

    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    function tick(now){
      const t = Math.min(1, (now - start) / dur);
      const k = easeOutCubic(t);

      const overshoot = 0.12 + 0.14 * strength;
      const overshotDest = (dest === 1) ? (1 + overshoot) : (0 - overshoot);

      if (t < 0.78){
        display = from + (overshotDest - from) * (k / 0.78);
      } else {
        const t2 = (t - 0.78) / 0.22;
        display = overshotDest + (dest - overshotDest) * (1 - Math.pow(1 - t2, 2));
      }

      display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
      setKnobFromDisplay();

      if (t < 1) requestAnimationFrame(tick);
      else {
        value = dest;
        target = dest;
        display = dest;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
        opts.onChange?.(value);
        opts.onSlingshotLand?.({ strength, dest, wrap, knob });
      }
    }
    requestAnimationFrame(tick);

    return true;
  }

  function isStationaryOnEdge(){
    const sinceSettle = performance.now() - lastSettleTime;
    const atLeft = value <= 0.0001;
    const atRight = value >= 0.9999;
    return { ok: (sinceSettle > 180) && (atLeft || atRight), atLeft, atRight };
  }

  async function gestureStartAudio(){
    // improves iOS reliability: try resume on any pointerdown
    try {
      await initAudio();
      await audio.ctx.resume();
    } catch {}
  }

  function onDown(e){
    if (isDown) return;
    e.preventDefault();

    // iOS audio: attempt resume on gesture
    gestureStartAudio();

    isDown = true;
    pointerId = e.pointerId;
    wrap.setPointerCapture(pointerId);
    knob.classList.add("isDown");

    // Determine if slingshot can arm (edge + settled)
    const edge = isStationaryOnEdge();
    canSlingshot = edge.ok;
    slingshotEdge = edge.atLeft ? "left" : (edge.atRight ? "right" : null);
    dragStartTime = performance.now();

    // IMPORTANT FIX:
    // If we're in edge-lock/slingshot mode, only start if they grabbed the knob itself.
    if (canSlingshot && e.target !== knob) {
      // keep it locked, do not yank it off-edge from big hitbox
      isDown = false;
      pointerId = null;
      knob.classList.remove("isDown");
      canSlingshot = false;
      slingshotEdge = null;
      return;
    }

    // Easter egg vertical pull (bottom slider only): only when BOTH sliders right AND bottom at right AND slingshot-armed
    if (vPullEnabled && opts.canEggPull?.() && slingshotEdge === "right") {
      vPulling = true;
      vStartY = e.clientY;
      vOffset = 0;
    }

    const v = pxToValue(e.clientX);

    if (canSlingshot && slingshotEdge === "left") {
      target = (v < 0) ? rubber(v) : v;
    } else if (canSlingshot && slingshotEdge === "right") {
      target = (v > 1) ? rubber(v) : v;
    } else {
      target = v;
    }
  }

  function onMove(e){
    if (!isDown || e.pointerId !== pointerId) return;
    e.preventDefault();

    // Easter egg vertical pull tracking
    if (vPullEnabled && vPulling) {
      const dy = e.clientY - vStartY;
      // allow pulling DOWN only
      vOffset = Math.max(0, Math.min(140, dy));
      // visual: move knob down while staying on right edge
      knob.style.top = `calc(50% + ${vOffset}px)`;
      return;
    }

    const v = pxToValue(e.clientX);

    if (canSlingshot && slingshotEdge === "left") {
      target = (v < 0) ? rubber(v) : v;
    } else if (canSlingshot && slingshotEdge === "right") {
      target = (v > 1) ? rubber(v) : v;
    } else {
      target = v;
    }
  }

  function onUp(e){
    if (!isDown || e.pointerId !== pointerId) return;
    e.preventDefault();

    isDown = false;
    knob.classList.remove("isDown");

    // Ensure first interaction starts audio (mobile)
    opts.onFirstInteract?.();

    // Easter egg release
    if (vPullEnabled && vPulling) {
      const fired = vOffset >= 48; // threshold
      vPulling = false;

      // reset knob Y visually before any further animations
      knob.style.top = "50%";

      if (fired) {
        opts.onEggFire?.({ wrap, knob });
        // keep bottom slider at right (do not change slider mechanics)
        value = 1;
        target = 1;
        display = 1;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
        opts.onChange?.(1);
        return;
      }

      // If not fired, continue with normal slingshot/snap behavior
    }

    if (maybeSlingshotRelease()) {
      canSlingshot = false;
      slingshotEdge = null;
      return;
    }

    const snapDist = opts.snapDist ?? 0.10;
    const dL = Math.abs(display - 0);
    const dR = Math.abs(display - 1);

    let dest = null;
    if (dL < snapDist) dest = 0;
    if (dR < snapDist) dest = 1;

    if (dest === null) {
      value = Math.max(0, Math.min(1, display));
      target = value;
      settleSpring(value);
      opts.onChange?.(value);
    } else {
      value = dest;
      target = dest;
      settleSpring(dest);
      opts.onChange?.(dest);
    }

    canSlingshot = false;
    slingshotEdge = null;
  }

  function animate(){
    // 20% less drag (more responsive): increase follow factor
    const follow = isDown ? 0.275 : 0.225;
    display = display + (target - display) * follow;

    display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
    setKnobFromDisplay();

    // speed-based glow: brightness depends on motion speed
    const v = Math.abs(display - lastDisplay) / (16.7 / 1000);
    lastDisplay = display;

    const speed = Math.min(1.0, v / 2.4);
    glowLevel = Math.max(glowLevel * 0.90, speed);

    // fade behavior: slower if moving slowly, brighter if moving fast
    const opacity = Math.min(0.98, (glowLevel * 0.92));
    glow.style.opacity = String(isDown ? opacity : opacity * 0.55);

    if (!isDown) {
      glowLevel *= 0.86;
      glow.style.opacity = String(Math.max(0, (glowLevel - 0.08) * 0.9));
    }

    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  wrap.addEventListener("pointerdown", onDown, { passive: false });
  window.addEventListener("pointermove", onMove, { passive: false });
  window.addEventListener("pointerup", onUp, { passive: false });
  window.addEventListener("pointercancel", onUp, { passive: false });

  return {
    get value(){ return Math.max(0, Math.min(1, value)); },
    set value(v){
      value = Math.max(0, Math.min(1, v));
      target = value;
      display = value;
      setKnobFromDisplay();
      opts.onChange?.(value);
    }
  };
}

/* =========================
   WIRE UP
========================= */

const panelEl = document.getElementById("panel");
const panelFx = makePanelFx(document.getElementById("panelFx"), panelEl);

const btnPlay = document.getElementById("btnPlay");

let tone = 0;
let blend = 0;

function applyMix(){
  if (!audio.ctx) return;
  setMix(tone, blend);
}

let firstGestureDone = false;

async function onFirstInteract(){
  if (firstGestureDone) return;
  firstGestureDone = true;
  try {
    await play();
    applyMix();
  } catch (err) {
    console.error(err);
  }
}

btnPlay.addEventListener("click", async (e) => {
  e.preventDefault();
  try{
    // iOS: click is a safe gesture; force resume
    await initAudio();
    await audio.ctx.resume();

    if (!audio.started) {
      await play();
      applyMix();
      return;
    }
    if (audio.playing) await pause();
    else await play();
  } catch (err){
    console.error(err);
  }
}, { passive:false });

// Spacebar Play/Pause
window.addEventListener("keydown", async (e) => {
  if (e.code !== "Space") return;
  e.preventDefault();
  try{
    await initAudio();
    await audio.ctx.resume();
    if (!audio.started) {
      await play();
      applyMix();
      return;
    }
    if (audio.playing) await pause();
    else await play();
  } catch {}
}, { passive:false });

function bothRight(){
  return (tone >= 0.999) && (blend >= 0.999);
}

let lastBothRight = false;

function checkReward(){
  const nowBoth = bothRight();
  if (nowBoth && !lastBothRight) {
    runRewardWave();

    // also give a bright burst at the right side (visual reward)
    const r = panelEl.getBoundingClientRect();
    // right-ish, mid-ish
    panelFx.extravagantBurst(r.width + 40, r.height * 0.55, 1.0);
  }
  lastBothRight = nowBoth;
}

function slingshotFX({ strength, dir, wrap }){
  const wr = wrap.getBoundingClientRect();
  // y position relative to panelFx canvas
  const pr = panelEl.getBoundingClientRect();
  const y = (wr.top - pr.top) + (wr.height / 2) + 40; // + inset offset
  panelFx.startRainbowSweep(y, dir, strength);
}

function slingshotLandFX({ strength, dest, wrap }){
  const wr = wrap.getBoundingClientRect();
  const pr = panelEl.getBoundingClientRect();
  const x = (wr.left - pr.left) + (dest === 1 ? wr.width : 0) + 40;
  const y = (wr.top - pr.top) + (wr.height / 2) + 40;
  panelFx.extravagantBurst(x, y, strength);
}

function eggPullAllowed(){
  // ONLY when both sliders right
  return bothRight();
}

function eggFire({ wrap, knob }){
  // "slingshot upwards into the top of the screen" + raining white dots + coupon popup
  // animate knob upward (visual only), then restore
  knob.style.transition = "transform 420ms cubic-bezier(.2,1.2,.2,1), top 420ms cubic-bezier(.2,1.2,.2,1)";
  knob.style.transform = "translate(-50%, -50%) scale(1.0) translateY(-340px)";
  setTimeout(() => {
    knob.style.transition = "";
    knob.style.transform = "translate(-50%, -50%)";
  }, 460);

  // Start rain + big burst at top
  panelFx.startRain();
  const pr = panelEl.getBoundingClientRect();
  panelFx.extravagantBurst(pr.width * 0.5 + 40, 20, 1.0);

  showCoupon();
}

const sliderTone = makeSlider({
  wrap: document.getElementById("wrapTone"),
  knob: document.getElementById("knobTone"),
  glow: document.getElementById("glowTone"),
  initial: 0,
  snapDist: 0.10,
  onFirstInteract,
  onSlingshot: slingshotFX,
  onSlingshotLand: slingshotLandFX,
  onChange: (v) => {
    tone = v;
    if (audio.started) applyMix();
    checkReward();
  }
});

const sliderBlend = makeSlider({
  wrap: document.getElementById("wrapBlend"),
  knob: document.getElementById("knobBlend"),
  glow: document.getElementById("glowBlend"),
  initial: 0,
  snapDist: 0.10,
  onFirstInteract,
  onSlingshot: slingshotFX,
  onSlingshotLand: slingshotLandFX,

  verticalEgg: true,
  canEggPull: eggPullAllowed,
  onEggFire: eggFire,

  onChange: (v) => {
    blend = v;
    if (audio.started) applyMix();
    checkReward();
  }
});

tone = sliderTone.value;
blend = sliderBlend.value;

document.addEventListener("touchmove", (e) => {
  // prevent page scroll inside embed while interacting
  if (firstGestureDone) e.preventDefault();
}, { passive:false });

updatePlayButton();
</script>
</body>
</html>