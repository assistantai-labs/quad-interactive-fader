

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Quad808 â€” Quad Interactive Mix Fader</title>

  <style>
    @font-face {
      font-family: "VCR OSD Mono";
      src: url("assets/fonts/VCR_OSD_MONO_1.001.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: transparent;
      overscroll-behavior: none;
    }

    body {
      -webkit-text-size-adjust: 100%;
      font-family: "VCR OSD Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }

    .stage {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px 16px 40px;
      box-sizing: border-box;
      background: transparent;
      position: relative;
    }

    .profileBadge {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
      z-index: 10;
      pointer-events: none;
      opacity: 0;
      transition: opacity 200ms ease-in;
    }
    
    .profileBadge.visible {
      opacity: 1;
    }
    
    .profileAvatar {
      width: clamp(72px, 9.75vw, 96px); /* 2/3 of original size */
      height: clamp(72px, 9.75vw, 96px); /* 2/3 of original size */
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.15);
      box-shadow: 0 8px 24px rgba(0,0,0,0.4), 0 0 16px rgba(255,255,255,0.1);
      object-fit: cover;
      display: block;
    }
    
    .profileLabel {
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 999px;
      padding: 2px 6px; /* 2/3 of original padding */
      letter-spacing: 0.15em;
      text-transform: uppercase;
      text-align: center;
      color: rgba(255,255,255,0.9);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      white-space: nowrap;
      margin-top: -10px; /* 2/3 of original margin */
      position: relative;
      z-index: 11;
    }
    
    .profileLabelLine {
      display: block;
      line-height: 0.3;
    }
    
    .profileLabelLine:first-child {
      font-size: clamp(4.5px, 0.55vw, 5.5px); /* 2/3 of original size */
      margin-bottom: -8px; /* Much tighter spacing */
    }
    
    .profileLabelLine:last-child {
      font-size: clamp(7px, 0.9vw, 9px); /* 2/3 of original size */
    }

    .panel {
      width: min(920px, 96vw);
      border-radius: 22px;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 18px 50px rgba(0,0,0,0.55);
      padding: 26px 26px 32px;
      box-sizing: border-box;
      color: #fff;
      position: relative;
      overflow: visible; /* allow FX beyond bounds */
    }

    /* Panel-wide FX overlay so explosions never clip */
    .panelFx {
      position: absolute;
      inset: -40px;            /* extra room so particles can fly */
      pointer-events: none;
      z-index: 3;              /* above labels so nothing clips it */
    }


    :root{
      --text: clamp(16px, 2.2vw, 22px);
      --label: clamp(14px, 2.0vw, 20px);
      --trackH: 4px;
      --knob: clamp(28px, 4.0vw, 38px);
      --knobPress: 1.40; /* expand 40% on press */
      --rowGap: clamp(14px, 2.2vw, 18px);
      --labelGap: 10px;
      /* Maximize hitbox: extend into gap between sliders, leaving ~1px buffer to prevent overlap */
      /* Gap is rowGap * 1.2, so each slider can extend by ~(gap/2 - 1px) */
      --hitH: calc(clamp(56px, 9.5vw, 74px) + clamp(7.4px, 1.32vw, 9.8px));
      --btnH: clamp(44px, 6vw, 54px);
      --btnW: clamp(120px, 18vw, 170px);

      /* end padding so mobile can still "pull past" without leaving screen */
      --endPad: clamp(18px, 3.2vw, 26px);
    }

    .rows {
      display: grid;
      gap: calc(var(--rowGap) * 1.2);
      position: relative;
      z-index: 2;
    }

    .row {
      display: grid;
      grid-template-rows: auto auto;
      gap: var(--labelGap);
    }

    .labels {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: var(--label);
      letter-spacing: 0.20em;
      text-transform: uppercase;
      color: #fff;
      opacity: 0.98;
      padding: 0 2px;
      pointer-events: none;
      position: relative;
      z-index: 2;
    }

    .trackWrap {
      position: relative;
      height: var(--hitH);
      display: flex;
      align-items: center;
      touch-action: none;
      padding-left: var(--endPad);
      padding-right: var(--endPad);
      box-sizing: border-box;
      overflow: visible;
      z-index: 2;
      cursor: pointer; /* Ensure cursor indicates clickability */
    }

    .track {
      width: 100%;
      height: var(--trackH);
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      position: relative;
      overflow: visible;
      pointer-events: none; /* Allow clicks to pass through to trackWrap */
    }

    .trackGlow {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(255,255,255,0.95);
      opacity: 0;
      filter: blur(0.4px);
      box-shadow: 0 0 14px rgba(255,255,255,0.35);
      pointer-events: none;
      transition: opacity 70ms linear;
    }

    .knob {
      position: absolute;
      left: 0%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: var(--knob);
      height: var(--knob);
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      will-change: transform, left, top, clip-path;
      touch-action: none;
      z-index: 5;
      transition: clip-path 0.05s ease-out;
    }

    .knob.isDown {
      transform: translate(-50%, -50%) scale(var(--knobPress));
      box-shadow: 0 10px 22px rgba(0,0,0,0.42);
    }

    @media (hover:hover){
      .trackWrap { cursor: grab; }
      .trackWrap:active { cursor: grabbing; }
    }

    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      padding-top: 20px;
      position: relative;
      z-index: 2;
    }

    .btn {
      height: var(--btnH);
      width: var(--btnW);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: var(--text);
      letter-spacing: 0.22em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      font-family: inherit;
    }

    .btn:active {
      transform: scale(1.03);
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.28);
    }


    @media (max-width: 520px){
      .panel{
        padding: 18px 16px 16px;
        border-radius: 18px;
      }
      .controls{ padding-top: 14px; }
    }
  </style>
</head>

<body>
  <div class="rewardWave" id="rewardWave"></div>
  <div class="stage">
    <div class="profileBadge" id="profileBadge">
      <img class="profileAvatar" id="profileAvatar" src="assets/IMG_7485.jpeg" alt="" onerror="this.onerror=null; this.parentElement.style.display='none'">
      <div class="profileLabel">
        <span class="profileLabelLine">MIXED BY</span><br>
        <span class="profileLabelLine">QUAD808</span>
      </div>
    </div>
    <div class="panel" id="panel">
      <canvas class="panelFx" id="panelFx"></canvas>


      <div class="rows">
        <div class="row" data-slider="tone">
          <div class="labels">
            <div>RAW</div>
            <div>MIXED</div>
          </div>

          <div class="trackWrap" id="wrapTone" aria-label="Raw Mixed Slider">
            <div class="track">
              <div class="trackGlow" id="glowTone"></div>
            </div>
            <div class="knob" id="knobTone" role="slider" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0"></div>
          </div>
        </div>

        <div class="row" data-slider="blend">
          <div class="labels">
            <div>VOCALS</div>
            <div>BEAT</div>
          </div>

          <div class="trackWrap" id="wrapBlend" aria-label="Vocals Beat Slider">
            <div class="track">
              <div class="trackGlow" id="glowBlend"></div>
            </div>
            <div class="knob" id="knobBlend" role="slider" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0"></div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="btnPlay">PLAY</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   AUDIO
========================= */

const FILES = {
  rawVocals: "assets/audio/RAW_VOCALS.wav",
  quadVocals: "assets/audio/QUAD_VOCALS.wav",
  rawFull: "assets/audio/RAW_VOCALS_BEAT.wav",
  quadFull: "assets/audio/QUAD_VOCALS_BEAT.wav",
};

let audio = {
  ctx: null,
  buffers: {},
  sources: {},
  gains: {},
  analyser: null,
  masterGain: null,
  dataArray: null,
  started: false,
  playing: false,
  loading: false,
};

async function initAudio() {
  if (audio.ctx) return;
  const Ctx = window.AudioContext || window.webkitAudioContext;
  audio.ctx = new Ctx();
  // iOS: Don't resume here - must be called from user gesture handler
  // Resume will be called from gestureStartAudio() or play button
}

async function loadBuffers() {
  if (audio.loading || Object.keys(audio.buffers).length) return;
  audio.loading = true;
  for (const [key, filename] of Object.entries(FILES)) {
    const res = await fetch(filename, { cache: "no-store" });
    if (!res.ok) throw new Error(`Missing file: ${filename}`);
    const arr = await res.arrayBuffer();
    audio.buffers[key] = await audio.ctx.decodeAudioData(arr);
  }
  audio.loading = false;
}

function buildGraph() {
  // iOS: sources must be started from user gesture, so we start them immediately
  // when this is called (which should be from ensureStarted after resume)
  
  // Create master gain and analyser to analyze final output
  audio.masterGain = audio.ctx.createGain();
  audio.analyser = audio.ctx.createAnalyser();
  audio.analyser.fftSize = 256; // Smaller for better performance
  audio.analyser.smoothingTimeConstant = 0.3; // Smooth the data
  const bufferLength = audio.analyser.frequencyBinCount;
  audio.dataArray = new Uint8Array(bufferLength);
  
  // Connect analyser to master gain, then to destination
  audio.masterGain.connect(audio.analyser);
  audio.analyser.connect(audio.ctx.destination);
  
  const make = (name, bufKey) => {
    const src = audio.ctx.createBufferSource();
    src.buffer = audio.buffers[bufKey];
    src.loop = true;
    const gain = audio.ctx.createGain();
    gain.gain.value = 0;
    src.connect(gain).connect(audio.masterGain); // Connect to master gain instead of destination
    audio.sources[name] = src;
    audio.gains[name] = gain;
  };

  make("rawVocals", "rawVocals");
  make("quadVocals", "quadVocals");
  make("rawFull", "rawFull");
  make("quadFull", "quadFull");

  // Start sources immediately (must be in user gesture context)
  // Use a small offset to ensure context is running
  const t0 = Math.max(audio.ctx.currentTime, audio.ctx.currentTime + 0.01);
  Object.values(audio.sources).forEach(s => {
    try {
      s.start(t0);
    } catch (err) {
      console.warn("Failed to start audio source:", err);
    }
  });
}

function setMix(tone, blend) {
  tone = Math.min(1, Math.max(0, tone));
  blend = Math.min(1, Math.max(0, blend));

  const vocalsLayer = (1 - blend);
  const fullLayer = blend;
  const rawPart = (1 - tone);
  const quadPart = tone;

  const now = audio.ctx ? audio.ctx.currentTime : 0;
  const ramp = 0.03;

  const setGain = (node, value) => {
    node.gain.cancelScheduledValues(now);
    node.gain.setTargetAtTime(value, now, ramp);
  };

  if (!audio.gains.rawVocals) return;

  setGain(audio.gains.rawVocals, vocalsLayer * rawPart);
  setGain(audio.gains.quadVocals, vocalsLayer * quadPart);
  setGain(audio.gains.rawFull, fullLayer   * rawPart);
  setGain(audio.gains.quadFull, fullLayer  * quadPart);
}

async function ensureStarted() {
  if (audio.started) return;
  await initAudio();
  // iOS: Must resume context before starting sources (must be in user gesture)
  if (audio.ctx.state !== 'running') {
    try {
      await audio.ctx.resume();
    } catch (err) {
      console.warn("Audio context resume failed:", err);
      throw err; // Re-throw so caller knows it failed
    }
  }
  await loadBuffers();
  buildGraph();
  audio.started = true;
  audio.playing = true;
  updatePlayButton();
}

async function play() {
  await ensureStarted();
  await audio.ctx.resume();
  audio.playing = true;
  updatePlayButton();
}

async function pause() {
  if (!audio.ctx) return;
  await audio.ctx.suspend();
  audio.playing = false;
  updatePlayButton();
}

function updatePlayButton() {
  const btn = document.getElementById("btnPlay");
  if (!btn) return;
  
  // Sync playing state with context state, but only if context exists and audio has started
  // This ensures button reflects actual state when context is resumed via gestures
  if (audio.ctx && audio.started) {
    const contextRunning = audio.ctx.state === 'running';
    // Only sync if context is running (don't override explicit pause)
    // This handles the case where gestureStartAudio resumes the context
    if (contextRunning) {
      audio.playing = true;
    }
    // If context is suspended, trust our internal state (pause() sets it correctly)
  }
  
  btn.textContent = audio.playing ? "PAUSE" : "PLAY";
}

/* =========================
   PANEL-WIDE FX (not clipped)
========================= */

function makePanelFx(canvas, panelEl) {
  const ctx = canvas.getContext("2d");
  const fx = {
    rain: null,        // {parts:[]}
    burst: null,       // {parts:[]}
    rainbow: null,     // {t, dir, strength, y}
    wave: null,        // {t, x0, y0}
    completion: null,  // {iris: {t}, shards: {t, parts:[]}, particles: {t, parts:[]}}
  };

  // Reusable particle pools to avoid allocations
  const particlePool = [];
  const shardPool = [];
  
  function getParticle() {
    return particlePool.pop() || { x: 0, y: 0, vx: 0, vy: 0, life: 1, size: 0, angle: 0, type: 0 };
  }
  
  function getShard() {
    return shardPool.pop() || { angle: 0, hue: 0 };
  }
  
  function releaseParticle(p) {
    if (particlePool.length < 100) particlePool.push(p);
  }
  
  function releaseShard(s) {
    if (shardPool.length < 50) shardPool.push(s);
  }

  let canvasWidth = 0;
  let canvasHeight = 0;

  function resize() {
    const r = panelEl.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor((r.width + 80) * dpr);
    canvas.height = Math.floor((r.height + 80) * dpr);
    canvas.style.width = (r.width + 80) + "px";
    canvas.style.height = (r.height + 80) + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    canvasWidth = r.width + 80;
    canvasHeight = r.height + 80;
  }

  const ro = new ResizeObserver(resize);
  ro.observe(panelEl);
  resize();

  function extravagantBurst(x, y, strength=1, trackWidth=null, pullDistance=null, knob=null) {
    const n = Math.floor(10 + 15 * strength); // Way fewer particles
    const parts = fx.burst?.parts || [];
    
    // Calculate slider speed during slingshot to match exactly
    // Slider now uses linear motion at constant speed (no easing)
    // Slider stops exactly at destination (0 or 1), no overshoot
    let slingshotSpeedPerFrame;
    if (trackWidth && pullDistance !== null) {
      // Calculate actual slingshot duration (with 0.4x multiplier for faster speed)
      const slingshotDurationMs = (235 - (strength * 55)) * 0.4;
      const slingshotDuration = slingshotDurationMs / 1000; // Convert to seconds
      
      // The slider travels from current position to destination (0 or 1)
      // Distance is the full track width (normalized to 1)
      const normalizedDistance = 1; // Full track width, no overshoot
      const actualDistance = trackWidth * normalizedDistance; // Convert to pixels
      
      // Linear motion: constant velocity = distance / time
      const constantVelocity = actualDistance / slingshotDuration; // pixels per second
      
      // Convert to pixels per frame (assuming 60fps)
      // Reduce speed for small balls (make them slower)
      slingshotSpeedPerFrame = (constantVelocity / 60) * 0.25; // 25% of slider speed (half of half speed)
    } else if (trackWidth) {
      // Fallback: use strength-based calculation
      const slingshotDurationMs = (235 - (strength * 55)) * 0.4;
      const slingshotDuration = slingshotDurationMs / 1000;
      const normalizedDistance = 1; // Full track width, no overshoot
      const actualDistance = trackWidth * normalizedDistance;
      const constantVelocity = actualDistance / slingshotDuration;
      slingshotSpeedPerFrame = (constantVelocity / 60) * 0.25; // 25% of slider speed (half of half speed)
    } else {
      // Fallback: estimate from panel width
      const panelRect = panelEl.getBoundingClientRect();
      const estimatedTrackWidth = panelRect.width * 0.8;
      const slingshotDurationMs = (235 - (strength * 55)) * 0.4;
      const slingshotDuration = slingshotDurationMs / 1000;
      const normalizedDistance = 1; // Full track width, no overshoot
      const actualDistance = estimatedTrackWidth * normalizedDistance;
      const constantVelocity = actualDistance / slingshotDuration;
      slingshotSpeedPerFrame = (constantVelocity / 60) * 0.25; // 25% of slider speed (half of half speed)
    }
    
    for (let i=0;i<n;i++){
      // Explode in all directions like a firework
      const angle = Math.random() * Math.PI * 2;
      // Use slingshot speed as base, with more variation for greater dispersion
      const speed = slingshotSpeedPerFrame * (1.5 + Math.random() * 1.5); // Much faster initial speed
      
      parts.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed, // Speed based on pull distance
        vy: Math.sin(angle) * speed, // Speed based on pull distance
        life: 1,
        size: 1 + Math.random() * 1.5, // Smaller balls
        hue: 0, // Will be calculated dynamically
        settled: false,
        createdAt: performance.now(), // Track when particle was created
        knob: knob, // Store reference to source slider knob
        explosionX: x, // Store explosion position (where knob was when it exploded)
        explosionY: y, // Store explosion position (where knob was when it exploded)
        orbitPhase: Math.random() * Math.PI * 2 // Random phase offset for staggered orbiting
      });
    }
    fx.burst = { parts };
  }

  function startRainbowSweep(y, dir, strength) {
    fx.rainbow = { t: 0, dir, strength: Math.min(1, Math.max(0.2, strength)), y };
  }

  function startRain() {
    const parts = [];
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const n = 160;
    for (let i=0;i<n;i++){
      parts.push({
        x: Math.random()*w,
        y: -20 - Math.random()*h*0.25,
        vy: 3.5 + Math.random()*5.5,
        life: 1,
        size: 1.5 + Math.random()*2.2
      });
    }
    fx.rain = { parts };
  }

  function triggerCompletionBurst() {
    // Get actual panel dimensions (iframe boundaries), not extended canvas
    const panelRect = panelEl.getBoundingClientRect();
    const w = panelRect.width;
    const h = panelRect.height;
    
    // White frame effect - lights up around the iframe
    fx.completion = {
      frame: { t: 0, w, h }
    };
  }

  function draw(dt) {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    
    // Get panel dimensions for iframe-constrained effects
    const panelRect = panelEl.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    // Calculate offset from canvas to panel (accounting for -40px inset)
    const offsetX = panelRect.left - canvasRect.left;
    const offsetY = panelRect.top - canvasRect.top;

    // White frame effect - lights up around the iframe when both sliders are on one side
    if (fx.completion) {
      const comp = fx.completion;
      const frameW = comp.frame?.w || panelRect.width;
      const frameH = comp.frame?.h || panelRect.height;
      
      if (comp.frame) {
        comp.frame.t += dt;
        const frameDuration = 0.6; // 600ms duration
        if (comp.frame.t < frameDuration) {
          const progress = comp.frame.t / frameDuration;
          // Fade in quickly, hold, then fade out
          let opacity;
          if (progress < 0.2) {
            opacity = progress / 0.2; // Fade in to 100%
          } else if (progress < 0.7) {
            opacity = 1.0; // Hold at 100%
          } else {
            opacity = 1.0 * (1 - (progress - 0.7) / 0.3); // Fade out
          }
          
          ctx.save();
          ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
          ctx.lineWidth = 4; // Frame thickness
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          // Draw white frame around the iframe
          const frameX = offsetX;
          const frameY = offsetY;
          const borderRadius = 22; // Match panel border-radius
          
          ctx.beginPath();
          // Top-left corner to top-right
          ctx.moveTo(frameX + borderRadius, frameY);
          ctx.lineTo(frameX + frameW - borderRadius, frameY);
          // Top-right corner
          ctx.arc(frameX + frameW - borderRadius, frameY + borderRadius, borderRadius, -Math.PI / 2, 0);
          // Right side
          ctx.lineTo(frameX + frameW, frameY + frameH - borderRadius);
          // Bottom-right corner
          ctx.arc(frameX + frameW - borderRadius, frameY + frameH - borderRadius, borderRadius, 0, Math.PI / 2);
          // Bottom side
          ctx.lineTo(frameX + borderRadius, frameY + frameH);
          // Bottom-left corner
          ctx.arc(frameX + borderRadius, frameY + frameH - borderRadius, borderRadius, Math.PI / 2, Math.PI);
          // Left side
          ctx.lineTo(frameX, frameY + borderRadius);
          // Top-left corner
          ctx.arc(frameX + borderRadius, frameY + borderRadius, borderRadius, Math.PI, -Math.PI / 2);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        } else {
          comp.frame = null;
        }
      }
      
      // Clean up when done
      if (!comp.frame) {
        fx.completion = null;
      }
    }

    // Rainbow sweep line effect (visual-only)
    if (fx.rainbow) {
      fx.rainbow.t += dt;
      const speed = 1.4 + 1.6 * fx.rainbow.strength;
      const p = (fx.rainbow.t * speed) % 1;
      const xCenter = fx.rainbow.dir === 1 ? (p*w) : ((1-p)*w);

      const grad = ctx.createLinearGradient(xCenter - 220, 0, xCenter + 220, 0);
      for (let i=0;i<=6;i++){
        grad.addColorStop(i/6, `hsla(${(i*60 + fx.rainbow.t*260)%360}, 95%, 62%, ${0.58*fx.rainbow.strength})`);
      }
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.lineCap = "round";
      ctx.lineWidth = 14;
      ctx.strokeStyle = grad;
      ctx.shadowColor = "rgba(255,255,255,0.25)";
      ctx.shadowBlur = 14;
      ctx.beginPath();
      ctx.moveTo(-20, fx.rainbow.y);
      ctx.lineTo(w+20, fx.rainbow.y);
      ctx.stroke();
      ctx.restore();

      // fade out automatically
      if (fx.rainbow.t > 0.65) fx.rainbow = null;
    }

    // Firework particles that fall to bottom
    if (fx.burst) {
      const parts = fx.burst.parts;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      // Get panel dimensions (iframe boundaries) - exact frame dimensions
      const panelRect = panelEl.getBoundingClientRect();
      const panelW = panelRect.width;
      const panelH = panelRect.height;
      const canvasOffset = 40; // Canvas has 40px inset
      const borderRadius = 22; // Match panel border-radius
      // Use exact frame bottom - no margin
      const bottomY = panelH + canvasOffset; // Exact bottom of iframe
      const leftBound = canvasOffset;
      const rightBound = panelW + canvasOffset;
      
      // Helper function to check if particle is within rounded corner bounds
      function isWithinRoundedBounds(x, y) {
        const relX = x - canvasOffset;
        const relY = y - canvasOffset;
        const cornerRadius = borderRadius;
        
        // Check bottom-left corner
        if (relX < cornerRadius && relY > panelH - cornerRadius) {
          const dx = relX - cornerRadius;
          const dy = relY - (panelH - cornerRadius);
          return (dx * dx + dy * dy) <= (cornerRadius * cornerRadius);
        }
        // Check bottom-right corner
        if (relX > panelW - cornerRadius && relY > panelH - cornerRadius) {
          const dx = relX - (panelW - cornerRadius);
          const dy = relY - (panelH - cornerRadius);
          return (dx * dx + dy * dy) <= (cornerRadius * cornerRadius);
        }
        // Within rectangular bounds
        return relX >= 0 && relX <= panelW && relY >= 0 && relY <= panelH;
      }
      
      // Get audio data once per frame for all particles
      let audioIntensity = 0;
      if (audio.analyser && audio.dataArray) {
        audio.analyser.getByteFrequencyData(audio.dataArray);
        // Get average intensity from low-mid frequencies (bass/beat range)
        let sum = 0;
        const startBin = 0;
        const endBin = Math.min(32, audio.dataArray.length); // Focus on lower frequencies
        for (let i = startBin; i < endBin; i++) {
          sum += audio.dataArray[i];
        }
        audioIntensity = (sum / (endBin - startBin)) / 255; // Normalize to 0-1
      }
      
      for (const pt of parts) {
        if (pt.settled) {
          // Check if settled particle gets disturbed (e.g., by other particles bouncing)
          // Allow settled particles to become active again if they move
          if (Math.abs(pt.vx) > 0.01 || Math.abs(pt.vy) > 0.01) {
            pt.settled = false;
          } else {
            // Calculate age and fade out after 2 seconds
            const age = (performance.now() - pt.createdAt) / 1000; // Age in seconds
            const fadeStartTime = 2; // Start fading after 2 seconds
            const fadeDuration = 2; // Fade out over 2 seconds (much slower fade)
            let fadeAlpha = 1;
            
            if (age > fadeStartTime) {
              // Fade out over fadeDuration seconds
              const fadeProgress = Math.min((age - fadeStartTime) / fadeDuration, 1);
              fadeAlpha = 1 - fadeProgress; // Fade from 1 to 0
            }
            
            // Particle has settled at bottom, make it white and solid
            const settledHue = 0; // Hue doesn't matter for white
            const settledSaturation = 0; // White has no saturation
            const settledLightness = 100; // White is maximum lightness
            const settledAlpha = 1.0; // Solid (fully opaque)
            
            // Apply fade-out alpha
            settledAlpha *= fadeAlpha;
            
            // Don't draw if completely faded
            if (settledAlpha <= 0) {
              continue;
            }
            
            ctx.fillStyle = `hsla(${settledHue}, ${settledSaturation}%, ${settledLightness}%, ${settledAlpha})`;
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI*2);
            ctx.fill();
            continue;
          }
        }
        
        // First explode outward, then slowly circle back to knob
        let merged = false;
        if (pt.explosionX !== undefined && pt.explosionY !== undefined) {
          // Use the stored explosion position (where the knob was when it exploded)
          const targetX = pt.explosionX;
          const targetY = pt.explosionY;
          
          // Calculate distance and direction to explosion position
          const dx = pt.x - targetX;
          const dy = pt.y - targetY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          // Calculate particle age
          const age = (performance.now() - pt.createdAt) / 1000; // Age in seconds
          const explosionPhase = 0.3; // Time for initial explosion (0.3 seconds)
          const orbitStartPhase = 1.5; // When to start orbiting back (1.5 seconds - longer float time)
          
          // Merge threshold: when particle gets very close to explosion position, it merges back
          const mergeRadius = 15; // Distance at which particle merges back into knob
          const orbitRadius = 40; // Preferred orbit radius
          
          // Phase 1: Explosion - let particles fly outward naturally
          if (age < explosionPhase) {
            // Just let them explode - no orbital motion yet
            // Particles will naturally move outward from initial velocity
          }
          // Phase 2: Start pulling back and orbiting
          else if (age >= orbitStartPhase) {
            // Check if particle has moved away from spawn point
            const spawnDist = Math.sqrt((pt.x - pt.explosionX) ** 2 + (pt.y - pt.explosionY) ** 2);
            const hasMovedAway = spawnDist > mergeRadius * 2;
            
            if (hasMovedAway && dist < mergeRadius) {
              // Particle has moved away and come back close enough to merge - mark for removal
              merged = true;
              pt.merged = true; // Mark as merged so it's removed
            } else if (dist > mergeRadius && dist > 0.1) {
              // Create very slow orbital motion around the knob with staggered phases
              const orbitalSpeed = 0.05; // Very slow orbital speed (radians per second)
              
              // Calculate current angle from center
              const currentAngle = Math.atan2(dy, dx);
              
              // Use orbit phase offset for staggering (default to 0 if not set)
              const phaseOffset = pt.orbitPhase || 0;
              
              // Calculate desired orbital velocity (tangential to circle)
              // Perpendicular to radius vector: rotate by 90 degrees, add phase offset
              const tangentAngle = currentAngle + Math.PI / 2 + phaseOffset;
              
              // Orbital velocity magnitude - constant speed for smooth orbit
              const orbitalVelocity = orbitalSpeed * dt * 60;
              
              // Apply orbital velocity (tangential) - normalized by distance to maintain constant angular velocity
              const angularVelocity = orbitalVelocity / Math.max(dist, 1); // Prevent division by zero
              pt.vx += Math.cos(tangentAngle) * angularVelocity * dist;
              pt.vy += Math.sin(tangentAngle) * angularVelocity * dist;
              
              // Apply stronger pull toward orbit radius
              const pullStrength = 0.15; // Stronger magnetic pull toward knob
              const distFromOrbit = dist - orbitRadius;
              const pullForce = pullStrength * distFromOrbit * dt * 60;
              if (dist > 0) {
                pt.vx -= (dx / dist) * pullForce;
                pt.vy -= (dy / dist) * pullForce;
              }
            }
          }
          // Phase 2.5: Transition phase - start gentle pull
          else {
            // Stronger pull toward center to start bringing them back
            const pullStrength = 0.1; // Stronger magnetic pull
            if (dist > orbitRadius && dist > 0.1) {
              pt.vx -= (dx / dist) * pullStrength * dt * 60;
              pt.vy -= (dy / dist) * pullStrength * dt * 60;
            }
          }
        }
        
        // Skip processing if merged
        if (merged) {
          continue;
        }
        
        pt.vx *= 0.98; // More friction for much slower movement
        
        // Update position
        pt.x += pt.vx;
        pt.y += pt.vy;
        
        // Helper function to check if point is inside rounded rectangle (accounting for particle size)
        function isInsideRoundedRect(x, y, size) {
          const relX = x - canvasOffset;
          const relY = y - canvasOffset;
          const r = borderRadius;
          const margin = size + 1.5; // Increased margin to keep particles further inside
          
          // Check if outside basic rectangle bounds (with margin)
          if (relX < margin || relX > panelW - margin || relY < margin || relY > panelH - margin) {
            return false;
          }
          
          // Check bottom-left corner
          if (relX < r && relY > panelH - r) {
            const cornerX = r;
            const cornerY = panelH - r;
            const dx = relX - cornerX;
            const dy = relY - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist <= (r - margin);
          }
          
          // Check bottom-right corner
          if (relX > panelW - r && relY > panelH - r) {
            const cornerX = panelW - r;
            const cornerY = panelH - r;
            const dx = relX - cornerX;
            const dy = relY - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist <= (r - margin);
          }
          
          // Check top-left corner
          if (relX < r && relY < r) {
            const cornerX = r;
            const cornerY = r;
            const dx = relX - cornerX;
            const dy = relY - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist <= (r - margin);
          }
          
          // Check top-right corner
          if (relX > panelW - r && relY < r) {
            const cornerX = panelW - r;
            const cornerY = r;
            const dx = relX - cornerX;
            const dy = relY - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist <= (r - margin);
          }
          
          // Inside rectangular area (not in corners)
          return true;
        }
        
        // Constrain particle to stay inside rounded rectangle
        const relX = pt.x - canvasOffset;
        const relY = pt.y - canvasOffset;
        const r = borderRadius;
        const margin = pt.size + 1.5; // Increased margin to keep particles further inside
        
        // Check if particle is outside bounds and push it back in with bounce
        if (!isInsideRoundedRect(pt.x, pt.y, pt.size)) {
          const isInTopLeftCorner = relX < r && relY < r;
          const isInTopRightCorner = relX > panelW - r && relY < r;
          const isInBottomLeftCorner = relX < r && relY > panelH - r;
          const isInBottomRightCorner = relX > panelW - r && relY > panelH - r;
          
          // Handle corners first
          if (isInTopLeftCorner) {
            // Top-left corner - bounce off curve
            const cornerX = canvasOffset + r;
            const cornerY = canvasOffset + r;
            const dx = pt.x - cornerX;
            const dy = pt.y - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = r - margin;
            if (dist > maxDist) {
              const angle = Math.atan2(dy, dx);
              pt.x = cornerX + Math.cos(angle) * maxDist;
              pt.y = cornerY + Math.sin(angle) * maxDist;
              // Bounce off corner curve
              const normalAngle = angle + Math.PI;
              const bounceSpeed = Math.sqrt(pt.vx * pt.vx + pt.vy * pt.vy) * 0.3;
              pt.vx = Math.cos(normalAngle) * bounceSpeed;
              pt.vy = Math.sin(normalAngle) * bounceSpeed;
            }
          } else if (isInTopRightCorner) {
            // Top-right corner - bounce off curve
            const cornerX = canvasOffset + panelW - r;
            const cornerY = canvasOffset + r;
            const dx = pt.x - cornerX;
            const dy = pt.y - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = r - margin;
            if (dist > maxDist) {
              const angle = Math.atan2(dy, dx);
              pt.x = cornerX + Math.cos(angle) * maxDist;
              pt.y = cornerY + Math.sin(angle) * maxDist;
              // Bounce off corner curve
              const normalAngle = angle + Math.PI;
              const bounceSpeed = Math.sqrt(pt.vx * pt.vx + pt.vy * pt.vy) * 0.3;
              pt.vx = Math.cos(normalAngle) * bounceSpeed;
              pt.vy = Math.sin(normalAngle) * bounceSpeed;
            }
          } else if (isInBottomLeftCorner) {
            // Bottom-left corner - bounce off curve
            const cornerX = canvasOffset + r;
            const cornerY = canvasOffset + panelH - r;
            const dx = pt.x - cornerX;
            const dy = pt.y - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = r - margin;
            if (dist > maxDist) {
              const angle = Math.atan2(dy, dx);
              pt.x = cornerX + Math.cos(angle) * maxDist;
              pt.y = cornerY + Math.sin(angle) * maxDist;
              // Bounce off corner curve
              const normalAngle = angle + Math.PI;
              const bounceSpeed = Math.sqrt(pt.vx * pt.vx + pt.vy * pt.vy) * 0.3;
              pt.vx = Math.cos(normalAngle) * bounceSpeed;
              pt.vy = Math.sin(normalAngle) * bounceSpeed;
            }
          } else if (isInBottomRightCorner) {
            // Bottom-right corner - bounce off curve
            const cornerX = canvasOffset + panelW - r;
            const cornerY = canvasOffset + panelH - r;
            const dx = pt.x - cornerX;
            const dy = pt.y - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = r - margin;
            if (dist > maxDist) {
              const angle = Math.atan2(dy, dx);
              pt.x = cornerX + Math.cos(angle) * maxDist;
              pt.y = cornerY + Math.sin(angle) * maxDist;
              // Bounce off corner curve
              const normalAngle = angle + Math.PI;
              const bounceSpeed = Math.sqrt(pt.vx * pt.vx + pt.vy * pt.vy) * 0.3;
              pt.vx = Math.cos(normalAngle) * bounceSpeed;
              pt.vy = Math.sin(normalAngle) * bounceSpeed;
            }
          } else {
            // Handle flat edges - bounce off all sides
            if (relX < margin) {
              // Left edge
              pt.x = canvasOffset + margin;
              pt.vx *= -0.3; // Bounce off left
            } else if (relX > panelW - margin) {
              // Right edge
              pt.x = canvasOffset + panelW - margin;
              pt.vx *= -0.3; // Bounce off right
            }
            
            if (relY < margin) {
              // Top edge
              pt.y = canvasOffset + margin;
              pt.vy *= -0.3; // Bounce off top
            } else if (relY > panelH - margin) {
              // Bottom edge
              pt.y = canvasOffset + panelH - margin;
              pt.vy *= -0.3; // Bounce off bottom
            }
          }
        }
        
        // Bounce off all edges - this is now handled in the constraint check above
        // Removed duplicate bottom check to avoid conflicts
        
        // Calculate fade-out after 4 seconds
        const age = (performance.now() - pt.createdAt) / 1000; // Age in seconds
        const fadeStartTime = 4.0; // Start fading after 4 seconds
        const fadeDuration = 1.0; // Fade out over 1 second
        let fadeAlpha = 1.0;
        
        if (age > fadeStartTime) {
          // Fade out over fadeDuration seconds
          const fadeProgress = Math.min((age - fadeStartTime) / fadeDuration, 1);
          fadeAlpha = 1 - fadeProgress; // Fade from 1 to 0
        }
        
        // Make balls white and solid
        const particleHue = 0; // Hue doesn't matter for white
        const particleSaturation = 0; // White has no saturation
        const particleLightness = 100; // White is maximum lightness
        let particleAlpha = 1.0; // Fully opaque
        
        // Apply fade-out alpha
        particleAlpha *= fadeAlpha;
        
        // Don't draw if completely faded
        if (particleAlpha <= 0) {
          continue;
        }
        
        ctx.fillStyle = `hsla(${particleHue}, ${particleSaturation}%, ${particleLightness}%, ${particleAlpha})`;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      
      // Track merge progress for knob fade-in synchronization
      const knobsWithParticles = new Map(); // Map of knob -> {total, merged, close}
      
      // First pass: count particles per knob
      for (const p of parts) {
        if (p.knob) {
          if (!knobsWithParticles.has(p.knob)) {
            knobsWithParticles.set(p.knob, { total: 0, merged: 0, close: 0 });
          }
          const stats = knobsWithParticles.get(p.knob);
          stats.total++;
          
          if (p.merged) {
            stats.merged++;
          } else {
            // Check if particle is close to merging - use explosion position
            if (p.explosionX !== undefined && p.explosionY !== undefined) {
              const dx = p.explosionX - p.x;
              const dy = p.explosionY - p.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const mergeRadius = 15;
              const closeThreshold = mergeRadius * 3; // Consider "close" when within 3x merge radius
              if (dist < closeThreshold) {
                stats.close++;
              }
            }
          }
        }
      }
      
      // Remove particles that have merged back into knob or faded out (after 5 seconds total)
      const now = performance.now();
      fx.burst.parts = parts.filter(p => {
        if (p.merged) return false; // Remove merged particles
        const age = (now - p.createdAt) / 1000;
        return age < 5; // Remove after 5 seconds (4s visible + 1s fade)
      });
      
      // Knob fade-in is now handled independently by setTimeout in the slider code
      // No particle-based fade-in logic needed here
      
      // Limit total particles to prevent memory issues
      if (fx.burst.parts.length > 2000) {
        // Remove oldest particles if too many
        fx.burst.parts = fx.burst.parts.filter(() => Math.random() > 0.1);
      }
    }

    // Rain
    if (fx.rain) {
      const parts = fx.rain.parts;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      for (const p of parts) {
        p.y += p.vy;
        p.vy *= 1.01;
        p.life -= 0.010;

        if (p.life > 0) {
          ctx.globalAlpha = Math.max(0, p.life);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
      fx.rain.parts = parts.filter(p => p.life > 0 && p.y < h + 40);
      if (fx.rain.parts.length === 0) fx.rain = null;
    }
  }

  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    draw(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  return {
    extravagantBurst,
    startRainbowSweep,
    startRain,
    triggerCompletionBurst,
  };
}

/* =========================
   REWARD WAVE
========================= */

const rewardWaveEl = document.getElementById("rewardWave");
let rewardArmed = true;

function runRewardWave(){
  // Rainbow flash effect removed
  // Function kept for compatibility but does nothing
}

/* =========================
   EASTER EGG (bottom knob vertical pull ONLY when both right)
========================= */

/* =========================
   SLIDER ENGINE
========================= */

function makeSlider(opts){
  const wrap = opts.wrap;
  const knob = opts.knob;
  const glow = opts.glow;

  let value = opts.initial ?? 0;
  let target = value;
  let display = value;

  let isDown = false;
  let pointerId = null;

  let lastDisplay = display;
  let glowLevel = 0;

  let canSlingshot = false;
  let slingshotEdge = null;
  let dragStartTime = 0;
  let knobHidden = false; // Track if knob is hidden after explosion

  let lastSettleTime = performance.now();

  // vertical easter egg state (bottom slider only)
  let vPullEnabled = !!opts.verticalEgg;
  let vPulling = false;
  let vStartY = 0;
  let vStartX = 0;
  let vOffset = 0;

  // Overpull clamp: knob always visible, hard stop holdable
  const OVERPULL_MAX = 0.34; // allow bigger than before but not infinite
  
  // Morph slingshot constants
  const MAX_OVERSCROLL = 0.15; // Maximum overscroll distance (normalized) for morphing
  const STRETCH_THRESHOLD = 0.25; // Minimum stretch to trigger slingshot
  const MORPH_SCALE_X = 0.65; // Horizontal stretch multiplier (more dramatic)
  const MORPH_SCALE_Y = 0.35; // Vertical compression multiplier (more dramatic)
  const MORPH_BULGE_FACTOR = 0.6; // How much the front bulges forward
  
  // Morph state
  let overscroll = 0; // How far beyond endpoint the pointer would be (0-1 normalized)
  let stretch = 0; // Computed stretch amount (0-1)
  let dragDirection = 0; // -1 for left, 1 for right, 0 for none
  let morphShake = 0; // Current shake offset

  function trackRect(){
    // track area is wrap inner content after padding
    const r = wrap.getBoundingClientRect();
    const cs = getComputedStyle(wrap);
    const pl = parseFloat(cs.paddingLeft) || 0;
    const pr = parseFloat(cs.paddingRight) || 0;
    return { r, pl, pr, w: Math.max(1, r.width - pl - pr) };
  }

  function pxToValue(px){
    const { r, pl, w } = trackRect();
    const x = px - r.left - pl;
    return x / w;
  }

  function setKnobFromDisplay(){
    // Don't update position if knob is hidden
    if (knobHidden || knob.style.display === "none") {
      return;
    }
    
    const { r, pl, w } = trackRect();

    // Calculate overscroll for morphing - based on how far display goes beyond 0-1
    if (isDown) {
      const clampedDisplay = Math.max(0, Math.min(1, display));
      const atLeftEdge = clampedDisplay <= 0.001;
      const atRightEdge = clampedDisplay >= 0.999;
      
      // Check if pulling back from edge
      const pullingBack = (atLeftEdge && target > 0.01) || (atRightEdge && target < 0.99);
      
      if (display < 0) {
        overscroll = Math.abs(display);
        dragDirection = -1;
      } else if (display > 1) {
        overscroll = display - 1;
        dragDirection = 1;
      } else if (pullingBack) {
        overscroll = 0;
        dragDirection = 0;
      } else if (atLeftEdge) {
        overscroll = 0.01;
        dragDirection = -1;
      } else if (atRightEdge) {
        overscroll = 0.01;
        dragDirection = 1;
      } else {
        overscroll = 0;
        dragDirection = 0;
      }
      
      stretch = Math.min(1, overscroll / MAX_OVERSCROLL);
      if ((atLeftEdge || atRightEdge) && !pullingBack && stretch < 0.15) {
        stretch = 0.15;
      }
    } else {
      overscroll = 0;
      stretch = 0;
      dragDirection = 0;
    }
    
    // Use original OVERPULL_MAX logic for visual position (allows ball to go slightly past)
    const d = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));

    // compute pixel position along track, then clamp within a hard stop range that stays on screen
    const x = pl + (d * w);
    const xMin = pl + (-OVERPULL_MAX * w);
    const xMax = pl + ((1+OVERPULL_MAX) * w);

    // convert to % of wrap width
    const xClamped = Math.max(xMin, Math.min(xMax, x));
    const pct = (xClamped / r.width) * 100;

    knob.style.left = pct + "%";
    knob.style.top = "50%";
    
    // Apply morphing transforms
    applyMorphTransform();

    knob.setAttribute("aria-valuenow", String(Math.max(0, Math.min(1, value))));
  }
  
  function applyMorphTransform() {
    // Don't apply transforms if knob is hidden
    if (knobHidden || knob.style.display === "none") {
      return;
    }
    
    const isPressed = knob.classList.contains("isDown");
    const baseScale = isPressed ? parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--knobPress')) || 1.4 : 1;
    
    // Calculate morph scales (more dramatic)
    const scaleX = 1 + (MORPH_SCALE_X * stretch);
    const scaleY = 1 - (MORPH_SCALE_Y * stretch);
    
    // Apply shake if stretch is high
    if (stretch > 0.75) {
      const shakeIntensity = (stretch - 0.75) / 0.25;
      morphShake = (Math.random() - 0.5) * 1.2 * shakeIntensity * 0.4; // More dramatic shake
    } else {
      morphShake = 0;
    }
    
    // Build transform string
    let transform = `translate(-50%, -50%)`;
    
    // Apply base press scale
    if (isPressed) {
      transform += ` scale(${baseScale})`;
    }
    
    // Apply morph scaling (after base scale) - more dramatic
    if (stretch > 0) {
      // Rotate to align with drag direction, then scale
      const angle = dragDirection === 1 ? 0 : Math.PI; // 0 for right, 180 for left
      transform += ` rotate(${angle}rad) scale(${scaleX}, ${scaleY}) rotate(${-angle}rad)`;
    }
    
    // Apply shake offset
    if (morphShake !== 0) {
      transform += ` translate(${morphShake}px, 0)`;
    }
    
    knob.style.transform = transform;
    
    // Apply clip-path for dramatic teardrop shape when stretched
    if (stretch > 0.05) {
      const knobSize = parseFloat(getComputedStyle(knob).width) || 28;
      const radius = knobSize / 2;
      const bulge = radius * (1 + stretch * MORPH_BULGE_FACTOR); // More dramatic bulge forward
      const tailCompress = radius * (1 - stretch * 0.3); // Compress back more
      
      if (dragDirection === 1) {
        // Stretching right - bulge points right
        knob.style.clipPath = `ellipse(${bulge}px ${radius * scaleY}px at ${bulge}px 50%)`;
      } else if (dragDirection === -1) {
        // Stretching left - bulge points left
        knob.style.clipPath = `ellipse(${bulge}px ${radius * scaleY}px at ${radius - bulge + radius}px 50%)`;
      }
    } else {
      knob.style.clipPath = "";
    }
  }

  function rubber(v){
    // keep rubber subtle; beyond ends compress
    if (v < 0) return v * 0.42;
    if (v > 1) return 1 + (v - 1) * 0.42;
    return v;
  }

  function settleSpring(to){
    const from = display;
    const start = performance.now();
    const dur = 260;

    function easeOutBack(t){
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    }

    function tick(now){
      const t = Math.min(1, (now - start) / dur);
      const eased = easeOutBack(t);
      display = from + (to - from) * eased;
      display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
      setKnobFromDisplay();
      if (t < 1) requestAnimationFrame(tick);
      else {
        display = to;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
      }
    }
    requestAnimationFrame(tick);
  }

  function pulledAmount(){
    // Use original logic: calculate based on display going beyond 0-1
    const d = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
    if (slingshotEdge === "left")  return Math.max(0, -d);
    if (slingshotEdge === "right") return Math.max(0, d - 1);
    return 0;
  }

  function maybeSlingshotRelease(){
    if (!canSlingshot || !slingshotEdge) return false;

    const pulled = pulledAmount();
    const dt = performance.now() - dragStartTime;

    // Mobile: much easier to trigger.
    const PULL_THRESHOLD = 0.030;
    const TOO_SLOW_MS = 1800;

    if (pulled < PULL_THRESHOLD) return false;
    if (dt > TOO_SLOW_MS) return false;

    const strength = Math.min(1.0, pulled / 0.12);
    const dest = (slingshotEdge === "left") ? 1 : 0;
    const dir = (dest === 1) ? 1 : -1;
    
    // Pass the actual pull distance for particle speed calculation
    const pullDistance = pulled; // Actual distance pulled past the line

    opts.onSlingshot?.({ strength, dir, wrap, knob, pullDistance });

    // Reset morph state before launch
    stretch = 0;
    overscroll = 0;
    dragDirection = 0;

    const from = display;
    const start = performance.now();
    const dur = (235 - (strength * 55)) * 0.4; // Much faster slingshot (0.4x duration)

    let exploded = false; // Track if explosion has happened
    let explosionTime = 0; // Time when explosion happened
    
    function tick(now){
      const t = Math.min(1, (now - start) / dur);

      // Linear motion at constant speed, then instantly stop at end
      if (t < 1) {
        // Constant speed: linear interpolation
        display = from + (dest - from) * t;
        setKnobFromDisplay();
      } else {
        // Instantly stop at destination - explode when hitting the wall
        display = dest;
        setKnobFromDisplay(); // Set position first
        
        // Hide knob completely and create explosion effect when it hits the wall
        if (!exploded) {
          exploded = true;
          explosionTime = now;
          knobHidden = true;
          
          // Get knob position for explosion BEFORE hiding (at the wall)
          const knobRect = knob.getBoundingClientRect();
          const panelRect = panelEl.getBoundingClientRect();
          const explosionX = (knobRect.left - panelRect.left) + (knobRect.width / 2) + 40; // Account for canvas offset
          const explosionY = (knobRect.top - panelRect.top) + (knobRect.height / 2) + 40;
          
          // Completely hide knob immediately - use !important via setProperty to override any styles
          knob.style.setProperty('transition', 'none', 'important');
          knob.style.setProperty('opacity', '0', 'important');
          knob.style.setProperty('visibility', 'hidden', 'important');
          knob.style.setProperty('display', 'none', 'important');
          knob.style.setProperty('pointer-events', 'none', 'important');
          knob.style.setProperty('width', '0', 'important');
          knob.style.setProperty('height', '0', 'important');
          knob.style.setProperty('transform', 'scale(0)', 'important');
          knob.style.setProperty('box-shadow', 'none', 'important');
          knob.style.setProperty('left', knob.style.left, 'important'); // Preserve position
          knob.style.setProperty('top', knob.style.top, 'important'); // Preserve position
          
          if (glow) {
            glow.style.setProperty('opacity', '0', 'important');
            glow.style.setProperty('visibility', 'hidden', 'important');
            glow.style.setProperty('display', 'none', 'important');
            glow.style.setProperty('pointer-events', 'none', 'important');
          }
          
          // Create explosion at knob position
          const trackWidth = wrap.getBoundingClientRect().width;
          panelFx.extravagantBurst(explosionX, explosionY, strength, trackWidth, pullDistance, knob);
        }
      }

      // Clamp to valid range (0 to 1)
      display = Math.max(0, Math.min(1, display));

      if (t < 1) requestAnimationFrame(tick);
      else {
        value = dest;
        target = dest;
        display = dest;
        
        // Fade in knob independently after a fixed delay
        const fadeDelay = 2000; // Start fading in after 2 seconds
        const fadeDuration = 3000; // Fade in slowly over 3 seconds
        
        // Start fade in after delay - independent of particles
        setTimeout(() => {
          // First, restore display and visibility (but keep opacity at 0 for fade)
          knob.style.removeProperty('display');
          knob.style.removeProperty('visibility');
          knob.style.removeProperty('pointer-events');
          knob.style.removeProperty('width');
          knob.style.removeProperty('height');
          knob.style.removeProperty('transform');
          knob.style.removeProperty('box-shadow');
          
          // Restore normal styles but keep opacity at 0 initially
          knob.style.display = "";
          knob.style.visibility = "visible";
          knob.style.pointerEvents = "";
          knob.style.width = "";
          knob.style.height = "";
          knob.style.transform = "";
          knob.style.boxShadow = "";
          
          // Set opacity to 0 first, then apply transition and fade to 1
          knob.style.opacity = "0";
          
          // Use requestAnimationFrame to ensure the 0 opacity is applied before transition
          requestAnimationFrame(() => {
            knob.style.transition = `opacity ${fadeDuration}ms linear`;
            knob.style.opacity = "1";
            knobHidden = false; // Re-enable interaction as it fades in
          });
          
          // Also restore glow
          if (glow) {
            glow.style.removeProperty('opacity');
            glow.style.removeProperty('visibility');
            glow.style.removeProperty('display');
            glow.style.removeProperty('pointer-events');
            glow.style.display = "";
            glow.style.visibility = "visible";
          }
        }, fadeDelay);
        
        lastSettleTime = performance.now();
        opts.onChange?.(value);
        opts.onSlingshotLand?.({ strength, dest, wrap, knob, pullDistance });
      }
    }
    requestAnimationFrame(tick);

    return true;
  }

  function isStationaryOnEdge(){
    const sinceSettle = performance.now() - lastSettleTime;
    const atLeft = value <= 0.0001;
    const atRight = value >= 0.9999;
    return { ok: (sinceSettle > 180) && (atLeft || atRight), atLeft, atRight };
  }

  async function gestureStartAudio(){
    // improves iOS reliability: try resume on any pointerdown (user gesture)
    try {
      if (!audio.ctx) {
        await initAudio();
      }
      // iOS: resume must be called from user gesture
      if (audio.ctx && audio.ctx.state !== 'running') {
        await audio.ctx.resume();
      }
      // If not started yet, start audio on first gesture
      if (!audio.started) {
        await ensureStarted();
        applyMix();
      }
      // If context is running and we have started audio, we're playing
      if (audio.ctx && audio.ctx.state === 'running' && audio.started) {
        audio.playing = true;
        updatePlayButton();
      }
    } catch (err) {
      console.warn("gestureStartAudio failed:", err);
    }
  }

  function onDown(e){
    if (isDown) return;
    // Prevent interaction if knob is hidden (opacity is 0 or very low)
    const knobOpacity = parseFloat(knob.style.opacity) || 1;
    if (knobOpacity < 0.1) return;
    e.preventDefault();

    // iOS audio: attempt resume on gesture
    gestureStartAudio();

    isDown = true;
    pointerId = e.pointerId;
    wrap.setPointerCapture(pointerId);
    knob.classList.add("isDown");

    // Determine if slingshot can arm (edge + settled)
    const edge = isStationaryOnEdge();
    canSlingshot = edge.ok;
    slingshotEdge = edge.atLeft ? "left" : (edge.atRight ? "right" : null);
    dragStartTime = performance.now();

    // IMPORTANT FIX:
    // If we're in edge-lock/slingshot mode, only start if they grabbed the knob itself.
    // For normal interaction, allow clicking anywhere in the trackWrap hitbox
    if (canSlingshot && e.target !== knob) {
      // keep it locked, do not yank it off-edge from big hitbox
      isDown = false;
      pointerId = null;
      knob.classList.remove("isDown");
      canSlingshot = false;
      slingshotEdge = null;
      return;
    }
    
    // Normal interaction: clicking anywhere in trackWrap (including track area) should work
    // The event listener is on wrap, so e.target will be wrap when clicking on empty trackWrap area
    // or knob when clicking on knob, or track (but track has pointer-events: none so it passes through)

    // Easter egg vertical pull (bottom slider only): only when BOTH sliders right AND bottom at right AND slingshot-armed
    if (vPullEnabled && opts.canEggPull?.() && slingshotEdge === "right") {
      vPulling = true;
      vStartY = e.clientY;
      vStartX = e.clientX;
      vOffset = 0;
    }

    const v = pxToValue(e.clientX);
    
    // Allow target to go beyond 0-1 for overscroll calculation
    // Visual position will be clamped in setKnobFromDisplay
    target = v;
  }

  function onMove(e){
    if (!isDown || e.pointerId !== pointerId) return;
    e.preventDefault();

    // Easter egg vertical pull tracking
    if (vPullEnabled && vPulling) {
      const dx = Math.abs(e.clientX - vStartX);
      const dy = e.clientY - vStartY;
      
      // If user moves horizontally significantly, exit vertical pull mode and allow normal slider movement
      if (dx > 15) {
        vPulling = false;
        vOffset = 0;
        knob.style.top = "50%";
        // Continue with normal horizontal movement below
      } else {
        // allow pulling DOWN only
        vOffset = Math.max(0, Math.min(140, dy));
        // visual: move knob down while staying on right edge
        knob.style.top = `calc(50% + ${vOffset}px)`;
        return;
      }
    }

    const v = pxToValue(e.clientX);
    
    // Allow target to go beyond 0-1 for overscroll calculation
    // Visual position will be clamped in setKnobFromDisplay
    target = v;
    
    // Update audio mix immediately during dragging for real-time feedback
    // Use clamped value for audio (0-1 range)
    const clampedTarget = Math.max(0, Math.min(1, target));
    if (opts.onChange) {
      opts.onChange(clampedTarget);
    }
  }

  function onUp(e){
    if (!isDown || e.pointerId !== pointerId) return;
    e.preventDefault();

    isDown = false;
    knob.classList.remove("isDown");

    // Ensure first interaction starts audio (mobile)
    opts.onFirstInteract?.();

    // Easter egg release
    if (vPullEnabled && vPulling) {
      const fired = vOffset >= 48; // threshold
      vPulling = false;

      // reset knob Y visually before any further animations
      knob.style.top = "50%";

      if (fired) {
        opts.onEggFire?.({ wrap, knob });
        // keep bottom slider at right (do not change slider mechanics)
        value = 1;
        target = 1;
        display = 1;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
        opts.onChange?.(1);
        return;
      }

      // If not fired, continue with normal slingshot/snap behavior
    }

    if (maybeSlingshotRelease()) {
      canSlingshot = false;
      slingshotEdge = null;
      return;
    }

    const snapDist = opts.snapDist ?? 0.10;
    const dL = Math.abs(display - 0);
    const dR = Math.abs(display - 1);

    let dest = null;
    if (dL < snapDist) dest = 0;
    if (dR < snapDist) dest = 1;

    if (dest === null) {
      value = Math.max(0, Math.min(1, display));
      target = value;
      settleSpring(value);
      opts.onChange?.(value);
    } else {
      value = dest;
      target = dest;
      settleSpring(dest);
      opts.onChange?.(dest);
    }

    canSlingshot = false;
    slingshotEdge = null;
  }

  function animate(){
    // Half drag (much more responsive): increase follow factor significantly
    const follow = isDown ? 0.6 : 0.5;
    const prevDisplay = display;
    display = display + (target - display) * follow;

    display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
    setKnobFromDisplay();
    
    // Update audio mix during dragging if display changed significantly
    // This ensures smooth audio crossfading while dragging
    if (isDown && Math.abs(display - prevDisplay) > 0.001 && opts.onChange) {
      const clampedDisplay = Math.max(0, Math.min(1, display));
      opts.onChange(clampedDisplay);
    }

    // speed-based glow: brightness depends on motion speed
    const v = Math.abs(display - lastDisplay) / (16.7 / 1000);
    lastDisplay = display;

    const speed = Math.min(1.0, v / 2.4);
    glowLevel = Math.max(glowLevel * 0.90, speed);

    // fade behavior: slower if moving slowly, brighter if moving fast
    const opacity = Math.min(0.98, (glowLevel * 0.92));
    glow.style.opacity = String(isDown ? opacity : opacity * 0.55);

    if (!isDown) {
      glowLevel *= 0.86;
      glow.style.opacity = String(Math.max(0, (glowLevel - 0.08) * 0.9));
    }

    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  wrap.addEventListener("pointerdown", onDown, { passive: false });
  window.addEventListener("pointermove", onMove, { passive: false });
  window.addEventListener("pointerup", onUp, { passive: false });
  window.addEventListener("pointercancel", onUp, { passive: false });

  const sliderAPI = {
    get value(){ return Math.max(0, Math.min(1, value)); },
    set value(v){
      value = Math.max(0, Math.min(1, v));
      target = value;
      display = value;
      setKnobFromDisplay();
      opts.onChange?.(value);
    },
    getDisplayValue: () => Math.max(0, Math.min(1, display))
  };
  
  return sliderAPI;
}

/* =========================
   WIRE UP
========================= */

const panelEl = document.getElementById("panel");
const panelFx = makePanelFx(document.getElementById("panelFx"), panelEl);

const btnPlay = document.getElementById("btnPlay");

let tone = 0;
let blend = 0;

function applyMix(){
  if (!audio.ctx) return;
  setMix(tone, blend);
}

let firstGestureDone = false;

async function onFirstInteract(){
  if (firstGestureDone) return;
  firstGestureDone = true;
  try {
    await play();
    applyMix();
    updatePlayButton();
  } catch (err) {
    console.error(err);
    updatePlayButton();
  }
}

btnPlay.addEventListener("click", async (e) => {
  e.preventDefault();
  try{
    // iOS: click is a safe gesture; force resume
    await initAudio();
    await audio.ctx.resume();

    if (!audio.started) {
      await play();
      applyMix();
      updatePlayButton();
      return;
    }
    if (audio.playing) {
      await pause();
    } else {
      await play();
    }
    updatePlayButton();
  } catch (err){
    console.error(err);
    updatePlayButton();
  }
}, { passive:false });

// Spacebar Play/Pause
window.addEventListener("keydown", async (e) => {
  if (e.code !== "Space") return;
  e.preventDefault();
  try{
    await initAudio();
    await audio.ctx.resume();
    if (!audio.started) {
      await play();
      applyMix();
      updatePlayButton();
      return;
    }
    if (audio.playing) {
      await pause();
    } else {
      await play();
    }
    updatePlayButton();
  } catch {
    updatePlayButton();
  }
}, { passive:false });

function bothRight(){
  return (tone >= 0.999) && (blend >= 0.999);
}

let lastBothRight = false;

function checkReward(){
  const nowBoth = bothRight();
  if (nowBoth && !lastBothRight) {
    runRewardWave();
  }
  lastBothRight = nowBoth;
}

/* =========================
   COMPLETION BURST TRACKING
========================= */

let completionBurstState = {
  toneMet: false,
  blendMet: false,
  toneMetTime: 0,
  blendMetTime: 0,
  lastTriggerTime: 0
};

const COMPLETION_THRESHOLD = 0.985;
const COMPLETION_HOLD_TIME = 150; // ms
const COMPLETION_RESET_THRESHOLD = 0.97;

function checkCompletionBurst() {
  // Only check if sliders exist
  if (!sliderTone || !sliderBlend) return;
  
  const now = performance.now();
  // Use display values for continuous checking during dragging (read-only)
  const toneDisplay = sliderTone.getDisplayValue();
  const blendDisplay = sliderBlend.getDisplayValue();
  const toneMet = toneDisplay >= COMPLETION_THRESHOLD;
  const blendMet = blendDisplay >= COMPLETION_THRESHOLD;
  
  // Track when each slider reaches threshold
  if (toneMet && !completionBurstState.toneMet) {
    completionBurstState.toneMet = true;
    completionBurstState.toneMetTime = now;
  } else if (!toneMet) {
    completionBurstState.toneMet = false;
    completionBurstState.toneMetTime = 0;
  }
  
  if (blendMet && !completionBurstState.blendMet) {
    completionBurstState.blendMet = true;
    completionBurstState.blendMetTime = now;
  } else if (!blendMet) {
    completionBurstState.blendMet = false;
    completionBurstState.blendMetTime = 0;
  }
  
  // Check if both have been met for required duration
  const bothMetForDuration = 
    completionBurstState.toneMet && 
    completionBurstState.blendMet &&
    completionBurstState.toneMetTime > 0 &&
    completionBurstState.blendMetTime > 0 &&
    (now - completionBurstState.toneMetTime) >= COMPLETION_HOLD_TIME &&
    (now - completionBurstState.blendMetTime) >= COMPLETION_HOLD_TIME;
  
  // Reset tracking if sliders drop below reset threshold (allows retrigger)
  if (toneDisplay < COMPLETION_RESET_THRESHOLD || blendDisplay < COMPLETION_RESET_THRESHOLD) {
    completionBurstState.toneMet = false;
    completionBurstState.blendMet = false;
    completionBurstState.toneMetTime = 0;
    completionBurstState.blendMetTime = 0;
  }
  
  // Trigger if conditions met (no cooldown - allows repeated triggers)
  // Only prevent immediate retrigger (within 100ms) to avoid spam
  const timeSinceLastTrigger = now - completionBurstState.lastTriggerTime;
  if (bothMetForDuration && timeSinceLastTrigger > 100) {
    panelFx.triggerCompletionBurst();
    completionBurstState.lastTriggerTime = now;
  }
  
  // Keep frame lit while both sliders are on the right side
  if (bothMetForDuration) {
    // Continuously trigger to keep frame visible
    if (timeSinceLastTrigger > 600) { // Re-trigger every 600ms to keep frame visible
      panelFx.triggerCompletionBurst();
      completionBurstState.lastTriggerTime = now;
    }
  } else {
    // Reset tracking when sliders move away
    completionBurstState.toneMetTime = 0;
    completionBurstState.blendMetTime = 0;
  }
}

function slingshotFX({ strength, dir, wrap }){
  // Rainbow sweep effect removed
  // Function kept for compatibility but does nothing
}

function slingshotLandFX({ strength, dest, wrap, pullDistance, knob }){
  const wr = wrap.getBoundingClientRect();
  const pr = panelEl.getBoundingClientRect();
  const x = (wr.left - pr.left) + (dest === 1 ? wr.width : 0) + 40;
  const y = (wr.top - pr.top) + (wr.height / 2) + 40;
  // Pass track width and pull distance so particles can match slingshot speed
  const trackWidth = wr.width;
  panelFx.extravagantBurst(x, y, strength, trackWidth, pullDistance, knob);
}

function eggPullAllowed(){
  // ONLY when both sliders right
  return bothRight();
}

function eggFire({ wrap, knob }){
  // "slingshot upwards into the top of the screen" + raining white dots
  // animate knob upward (visual only), then restore
  knob.style.transition = "transform 420ms cubic-bezier(.2,1.2,.2,1), top 420ms cubic-bezier(.2,1.2,.2,1)";
  knob.style.transform = "translate(-50%, -50%) scale(1.0) translateY(-340px)";
  setTimeout(() => {
    knob.style.transition = "";
    knob.style.transform = "translate(-50%, -50%)";
  }, 460);

  // Start rain + big burst at top
  panelFx.startRain();
  const pr = panelEl.getBoundingClientRect();
  // Get track width from one of the sliders for speed calculation
  const trackWidth = document.getElementById("wrapTone")?.getBoundingClientRect().width || pr.width * 0.8;
  // Use default pull distance for egg fire
  panelFx.extravagantBurst(pr.width * 0.5 + 40, 20, 1.0, trackWidth, 0.12, knob);
}

const sliderTone = makeSlider({
  wrap: document.getElementById("wrapTone"),
  knob: document.getElementById("knobTone"),
  glow: document.getElementById("glowTone"),
  initial: 0,
  snapDist: 0.10,
  onFirstInteract,
  onSlingshot: slingshotFX,
  onSlingshotLand: slingshotLandFX,
  onChange: (v) => {
    tone = v;
    if (audio.started) applyMix();
    checkReward();
  }
});

const sliderBlend = makeSlider({
  wrap: document.getElementById("wrapBlend"),
  knob: document.getElementById("knobBlend"),
  glow: document.getElementById("glowBlend"),
  initial: 0,
  snapDist: 0.10,
  onFirstInteract,
  onSlingshot: slingshotFX,
  onSlingshotLand: slingshotLandFX,

  verticalEgg: true,
  canEggPull: eggPullAllowed,
  onEggFire: eggFire,

  onChange: (v) => {
    blend = v;
    if (audio.started) applyMix();
    checkReward();
  }
});

tone = sliderTone.value;
blend = sliderBlend.value;

// Continuous check for completion burst (runs every frame after sliders are created)
function completionBurstLoop() {
  checkCompletionBurst();
  requestAnimationFrame(completionBurstLoop);
}
requestAnimationFrame(completionBurstLoop);

document.addEventListener("touchmove", (e) => {
  // prevent page scroll inside embed while interacting
  if (firstGestureDone) e.preventDefault();
}, { passive:false });

updatePlayButton();

// Profile badge: hide if image missing, fade in if loaded
(function(){
  const badge = document.getElementById("profileBadge");
  const avatar = document.getElementById("profileAvatar");
  if (!badge || !avatar) return;
  
  // Check if image loads successfully
  const showBadge = () => {
    badge.classList.add("visible");
  };
  
  const hideBadge = () => {
    badge.style.display = "none";
  };
  
  // Check image load status
  if (avatar.complete) {
    if (avatar.naturalWidth > 0 && avatar.naturalHeight > 0) {
      showBadge();
    } else {
      hideBadge();
    }
  } else {
    avatar.addEventListener("load", showBadge, { once: true });
    avatar.addEventListener("error", hideBadge, { once: true });
    // Also check after a short delay in case onerror fires before this
    setTimeout(() => {
      if (avatar.naturalWidth === 0 && avatar.naturalHeight === 0 && badge.style.display !== "none") {
        hideBadge();
      }
    }, 100);
  }
})();
</script>
</body>
</html>