

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Quad808 — Quad Interactive Mix Fader</title>

  <style>
    @font-face {
      font-family: "VCR OSD Mono";
      src: url("assets/fonts/VCR_OSD_MONO_1.001.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: transparent;
      overscroll-behavior: none;
    }

    body {
      -webkit-text-size-adjust: 100%;
      font-family: "VCR OSD Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }

    .stage {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px 16px;
      box-sizing: border-box;
      background: transparent;
    }

    .panel {
      width: min(920px, 96vw);
      border-radius: 22px;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 18px 50px rgba(0,0,0,0.55);
      padding: 26px 26px 22px;
      box-sizing: border-box;
      color: #fff;
      position: relative;
      overflow: visible; /* allow FX beyond bounds */
    }

    /* Panel-wide FX overlay so explosions never clip */
    .panelFx {
      position: absolute;
      inset: -40px;            /* extra room so particles can fly */
      pointer-events: none;
      z-index: 3;              /* above labels so nothing clips it */
    }


    :root{
      --text: clamp(16px, 2.2vw, 22px);
      --label: clamp(14px, 2.0vw, 20px);
      --trackH: 4px;
      --knob: clamp(28px, 4.0vw, 38px);
      --knobPress: 1.40; /* expand 40% on press */
      --rowGap: clamp(14px, 2.2vw, 18px);
      --labelGap: 10px;
      --hitH: clamp(56px, 9.5vw, 74px);
      --btnH: clamp(44px, 6vw, 54px);
      --btnW: clamp(120px, 18vw, 170px);

      /* end padding so mobile can still "pull past" without leaving screen */
      --endPad: clamp(18px, 3.2vw, 26px);
    }

    .rows {
      display: grid;
      gap: calc(var(--rowGap) * 1.2);
      position: relative;
      z-index: 2;
    }

    .row {
      display: grid;
      grid-template-rows: auto auto;
      gap: var(--labelGap);
    }

    .labels {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: var(--label);
      letter-spacing: 0.20em;
      text-transform: uppercase;
      color: #fff;
      opacity: 0.98;
      padding: 0 2px;
      pointer-events: none;
      position: relative;
      z-index: 2;
    }

    .trackWrap {
      position: relative;
      height: var(--hitH);
      display: flex;
      align-items: center;
      touch-action: none;
      padding-left: var(--endPad);
      padding-right: var(--endPad);
      box-sizing: border-box;
      overflow: visible;
      z-index: 2;
    }

    .track {
      width: 100%;
      height: var(--trackH);
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      position: relative;
      overflow: visible;
    }

    .trackGlow {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(255,255,255,0.95);
      opacity: 0;
      filter: blur(0.4px);
      box-shadow: 0 0 14px rgba(255,255,255,0.35);
      pointer-events: none;
      transition: opacity 70ms linear;
    }

    .knob {
      position: absolute;
      left: 0%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: var(--knob);
      height: var(--knob);
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      will-change: transform, left, top;
      touch-action: none;
      z-index: 5;
    }

    .knob.isDown {
      transform: translate(-50%, -50%) scale(var(--knobPress));
      box-shadow: 0 10px 22px rgba(0,0,0,0.42);
    }

    @media (hover:hover){
      .trackWrap { cursor: grab; }
      .trackWrap:active { cursor: grabbing; }
    }

    .controls {
      display: flex;
      justify-content: center;
      padding-top: 18px;
      position: relative;
      z-index: 2;
    }

    .btn {
      height: var(--btnH);
      width: var(--btnW);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: var(--text);
      letter-spacing: 0.22em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      font-family: inherit;
    }

    .btn:active {
      transform: scale(1.03);
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.28);
    }

    /* Easter egg popup */
    .coupon {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 6;
      background: rgba(0,0,0,0.72);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 16px;
      padding: 16px 18px;
      min-width: min(320px, 86vw);
      text-align: center;
      opacity: 0;
      pointer-events: none;
      box-shadow: 0 18px 48px rgba(0,0,0,0.55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .coupon.show {
      opacity: 1;
      pointer-events: auto;
      animation: popIn 220ms ease-out;
    }
    @keyframes popIn {
      from { transform: translate(-50%, -50%) scale(0.92); opacity: 0; }
      to   { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    .coupon .title {
      font-size: clamp(16px, 2.4vw, 20px);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      margin-bottom: 10px;
    }
    .coupon .code {
      font-size: clamp(18px, 2.8vw, 24px);
      letter-spacing: 0.22em;
      font-weight: 700;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      display: inline-block;
      margin-bottom: 10px;
    }
    .coupon .sub {
      font-size: clamp(12px, 1.8vw, 14px);
      opacity: 0.85;
      letter-spacing: 0.06em;
    }

    @media (max-width: 520px){
      .panel{
        padding: 18px 16px 16px;
        border-radius: 18px;
      }
      .controls{ padding-top: 14px; }
    }
  </style>
</head>

<body>
  <div class="rewardWave" id="rewardWave"></div>
  <div class="stage">
    <div class="panel" id="panel">
      <canvas class="panelFx" id="panelFx"></canvas>

      <div class="coupon" id="coupon">
        <div class="title">Easter Egg Unlocked</div>
        <div class="code" id="couponCode">QUAD50</div>
        <div class="sub">50% off your first order</div>
      </div>

      <div class="rows">
        <div class="row" data-slider="tone">
          <div class="labels">
            <div>RAW</div>
            <div>MIXED</div>
          </div>

          <div class="trackWrap" id="wrapTone" aria-label="Raw Mixed Slider">
            <div class="track">
              <div class="trackGlow" id="glowTone"></div>
            </div>
            <div class="knob" id="knobTone" role="slider" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0"></div>
          </div>
        </div>

        <div class="row" data-slider="blend">
          <div class="labels">
            <div>VOCALS</div>
            <div>BEAT</div>
          </div>

          <div class="trackWrap" id="wrapBlend" aria-label="Vocals Beat Slider">
            <div class="track">
              <div class="trackGlow" id="glowBlend"></div>
            </div>
            <div class="knob" id="knobBlend" role="slider" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0"></div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="btnPlay">PLAY</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   AUDIO
========================= */

const FILES = {
  rawVocals: "assets/audio/RAW_VOCALS.wav",
  quadVocals: "assets/audio/QUAD_VOCALS.wav",
  rawFull: "assets/audio/RAW_VOCALS_BEAT.wav",
  quadFull: "assets/audio/QUAD_VOCALS_BEAT.wav",
};

let audio = {
  ctx: null,
  buffers: {},
  sources: {},
  gains: {},
  started: false,
  playing: false,
  loading: false,
};

async function initAudio() {
  if (audio.ctx) return;
  const Ctx = window.AudioContext || window.webkitAudioContext;
  audio.ctx = new Ctx();
  // iOS: resume must happen on a user gesture; we call resume from pointer handlers too.
  await audio.ctx.resume();
}

async function loadBuffers() {
  if (audio.loading || Object.keys(audio.buffers).length) return;
  audio.loading = true;
  for (const [key, filename] of Object.entries(FILES)) {
    const res = await fetch(filename, { cache: "no-store" });
    if (!res.ok) throw new Error(`Missing file: ${filename}`);
    const arr = await res.arrayBuffer();
    audio.buffers[key] = await audio.ctx.decodeAudioData(arr);
  }
  audio.loading = false;
}

function buildGraph() {
  const make = (name, bufKey) => {
    const src = audio.ctx.createBufferSource();
    src.buffer = audio.buffers[bufKey];
    src.loop = true;
    const gain = audio.ctx.createGain();
    gain.gain.value = 0;
    src.connect(gain).connect(audio.ctx.destination);
    audio.sources[name] = src;
    audio.gains[name] = gain;
  };

  make("rawVocals", "rawVocals");
  make("quadVocals", "quadVocals");
  make("rawFull", "rawFull");
  make("quadFull", "quadFull");

  const t0 = audio.ctx.currentTime + 0.02;
  Object.values(audio.sources).forEach(s => s.start(t0));
}

function setMix(tone, blend) {
  tone = Math.min(1, Math.max(0, tone));
  blend = Math.min(1, Math.max(0, blend));

  const vocalsLayer = (1 - blend);
  const fullLayer = blend;
  const rawPart = (1 - tone);
  const quadPart = tone;

  const now = audio.ctx ? audio.ctx.currentTime : 0;
  const ramp = 0.03;

  const setGain = (node, value) => {
    node.gain.cancelScheduledValues(now);
    node.gain.setTargetAtTime(value, now, ramp);
  };

  if (!audio.gains.rawVocals) return;

  setGain(audio.gains.rawVocals, vocalsLayer * rawPart);
  setGain(audio.gains.quadVocals, vocalsLayer * quadPart);
  setGain(audio.gains.rawFull, fullLayer   * rawPart);
  setGain(audio.gains.quadFull, fullLayer  * quadPart);
}

async function ensureStarted() {
  if (audio.started) return;
  await initAudio();
  await loadBuffers();
  buildGraph();
  audio.started = true;
  audio.playing = true;
  updatePlayButton();
}

async function play() {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:412',message:'play() entry',data:{ctxState:audio.ctx?.state,started:audio.started,playing:audio.playing},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  await ensureStarted();
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:414',message:'before resume in play()',data:{ctxState:audio.ctx?.state},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  await audio.ctx.resume();
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:415',message:'after resume in play()',data:{ctxState:audio.ctx?.state},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
  // #endregion
  audio.playing = true;
  updatePlayButton();
}

async function pause() {
  if (!audio.ctx) return;
  await audio.ctx.suspend();
  audio.playing = false;
  updatePlayButton();
}

function updatePlayButton() {
  const btn = document.getElementById("btnPlay");
  if (!btn) return;
  
  // Sync playing state with context state, but only if context exists and audio has started
  // This ensures button reflects actual state when context is resumed via gestures
  if (audio.ctx && audio.started) {
    const contextRunning = audio.ctx.state === 'running';
    // Only sync if context is running (don't override explicit pause)
    // This handles the case where gestureStartAudio resumes the context
    if (contextRunning) {
      audio.playing = true;
    }
    // If context is suspended, trust our internal state (pause() sets it correctly)
  }
  
  btn.textContent = audio.playing ? "PAUSE" : "PLAY";
}

/* =========================
   PANEL-WIDE FX (not clipped)
========================= */

function makePanelFx(canvas, panelEl) {
  const ctx = canvas.getContext("2d");
  const fx = {
    rain: null,        // {parts:[]}
    burst: null,       // {parts:[]}
    rainbow: null,     // {t, dir, strength, y}
    wave: null,        // {t, x0, y0}
    completion: null,  // {iris: {t}, shards: {t, parts:[]}, particles: {t, parts:[]}}
  };

  // Reusable particle pools to avoid allocations
  const particlePool = [];
  const shardPool = [];
  
  function getParticle() {
    return particlePool.pop() || { x: 0, y: 0, vx: 0, vy: 0, life: 1, size: 0, angle: 0, type: 0 };
  }
  
  function getShard() {
    return shardPool.pop() || { angle: 0, hue: 0 };
  }
  
  function releaseParticle(p) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:472',message:'releaseParticle',data:{poolSize:particlePool.length,willAdd:particlePool.length<100},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion
    if (particlePool.length < 100) particlePool.push(p);
  }
  
  function releaseShard(s) {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:476',message:'releaseShard',data:{poolSize:shardPool.length,willAdd:shardPool.length<50},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
    // #endregion
    if (shardPool.length < 50) shardPool.push(s);
  }

  function resize() {
    const r = panelEl.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor((r.width + 80) * dpr);
    canvas.height = Math.floor((r.height + 80) * dpr);
    canvas.style.width = (r.width + 80) + "px";
    canvas.style.height = (r.height + 80) + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  const ro = new ResizeObserver(resize);
  ro.observe(panelEl);
  resize();

  function extravagantBurst(x, y, strength=1) {
    const n = Math.floor(50 + 80 * strength);
    const parts = [];
    for (let i=0;i<n;i++){
      const a = Math.random() * Math.PI * 2;
      const sp = (3.2 + 8.5 * strength) * (0.6 + Math.random()*0.9);
      parts.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        life: 1,
        size: 1.8 + Math.random()*2.8,
        hue: (Math.random()*360)|0
      });
    }
    fx.burst = { parts };
  }

  function startRainbowSweep(y, dir, strength) {
    fx.rainbow = { t: 0, dir, strength: Math.min(1, Math.max(0.2, strength)), y };
  }

  function startRain() {
    const parts = [];
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const n = 160;
    for (let i=0;i<n;i++){
      parts.push({
        x: Math.random()*w,
        y: -20 - Math.random()*h*0.25,
        vy: 3.5 + Math.random()*5.5,
        life: 1,
        size: 1.5 + Math.random()*2.2
      });
    }
    fx.rain = { parts };
  }

  function triggerCompletionBurst() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const centerX = w / 2;
    const centerY = h / 2;
    
    // Check prefers-reduced-motion
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    if (prefersReducedMotion) {
      // Minimal flash only
      fx.completion = {
        iris: { t: 0 },
        shards: null,
        particles: null
      };
      return;
    }
    
    // Layer A: Iris Flash (40-120ms)
    fx.completion = {
      iris: { t: 0 },
      shards: { t: 0, parts: [] },
      particles: { t: 0, parts: [] }
    };
    
    // Layer B: Prismatic Shard Ring (24 shards for more intensity)
    const numShards = 24;
    for (let i = 0; i < numShards; i++) {
      const shard = getShard();
      shard.angle = (i / numShards) * Math.PI * 2;
      // Cyan → Violet → Magenta gradient
      shard.hue = 180 + (i / numShards) * 180;
      fx.completion.shards.parts.push(shard);
    }
    
    // Layer C: Particle Drift (80 particles for more intensity)
    const numParticles = 80;
    for (let i = 0; i < numParticles; i++) {
      const p = getParticle();
      const angle = Math.random() * Math.PI * 2;
      const speed = 1.2 + Math.random() * 1.8;
      p.x = centerX;
      p.y = centerY;
      p.vx = Math.cos(angle) * speed;
      p.vy = Math.sin(angle) * speed;
      p.life = 1;
      p.size = 2.0 + Math.random() * 3.5; // Larger particles
      p.angle = angle;
      p.type = Math.random() < 0.5 ? 0 : 1; // 0 = square, 1 = line
      fx.completion.particles.parts.push(p);
    }
  }

  function draw(dt) {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const centerX = w / 2;
    const centerY = h / 2;
    // #region agent log
    try {
      ctx.clearRect(0,0,w,h);
    } catch (err) {
      fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:586',message:'canvas context error',data:{error:err.message},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
      return;
    }
    // #endregion

    // Completion burst effect
    if (fx.completion) {
      const comp = fx.completion;
      
      // Layer A: Iris Flash (40-120ms)
      if (comp.iris) {
        comp.iris.t += dt;
        const irisDuration = 0.12;
        if (comp.iris.t < irisDuration) {
          let opacity = 0;
          if (comp.iris.t < 0.04) {
            opacity = comp.iris.t / 0.04;
          } else {
            opacity = 1 - ((comp.iris.t - 0.04) / (irisDuration - 0.04));
          }
          
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          // Larger, brighter flash
          const radius = Math.min(w, h) * 0.55 * (1 + comp.iris.t * 3);
          const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
          grad.addColorStop(0, `rgba(255, 255, 255, ${opacity * 1.0})`);
          grad.addColorStop(0.3, `rgba(255, 255, 255, ${opacity * 0.9})`);
          grad.addColorStop(0.6, `rgba(255, 255, 255, ${opacity * 0.7})`);
          grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          // Add glow effect
          ctx.shadowBlur = 40;
          ctx.shadowColor = `rgba(255, 255, 255, ${opacity * 0.6})`;
          ctx.fill();
          ctx.restore();
        } else {
          comp.iris = null;
        }
      }
      
      // Layer B: Prismatic Shard Ring (120-650ms)
      if (comp.shards && comp.shards.parts.length > 0) {
        comp.shards.t += dt;
        const shardDuration = 0.65;
        if (comp.shards.t < shardDuration) {
          const progress = comp.shards.t / shardDuration;
          const eased = 1 - Math.pow(1 - progress, 3);
          
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          ctx.lineCap = "round";
          ctx.lineWidth = 3.5; // Thicker, more visible shards
          
          for (const shard of comp.shards.parts) {
            const dist = eased * Math.min(w, h) * 0.45; // Expand further
            const rotation = eased * 0.2; // More rotation
            const angle = shard.angle + rotation;
            const shardLength = 12 + eased * 4; // Longer shards
            const x1 = centerX + Math.cos(angle) * (dist - shardLength);
            const y1 = centerY + Math.sin(angle) * (dist - shardLength);
            const x2 = centerX + Math.cos(angle) * (dist + shardLength);
            const y2 = centerY + Math.sin(angle) * (dist + shardLength);
            
            const life = 1 - progress;
            const alpha = life * 1.0; // Brighter
            const hue = shard.hue + progress * 40; // More color shift
            // More saturated colors
            ctx.strokeStyle = `hsla(${hue % 360}, 95%, 70%, ${alpha})`;
            ctx.shadowBlur = 8;
            ctx.shadowColor = `hsla(${hue % 360}, 95%, 70%, ${alpha * 0.5})`;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          }
          
          ctx.restore();
        } else {
          comp.shards.parts.forEach(s => releaseShard(s));
          comp.shards = null;
        }
      }
      
      // Layer C: Particle Drift (400-1600ms)
      if (comp.particles && comp.particles.parts.length > 0) {
        comp.particles.t += dt;
        const particleDuration = 1.6;
        if (comp.particles.t < particleDuration) {
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          
          for (const p of comp.particles.parts) {
            p.x += p.vx;
            p.y += p.vy;
            p.vx *= 0.985; // Slower decay for longer trails
            p.vy *= 0.985;
            
            const elapsed = comp.particles.t;
            if (elapsed < 0.3) {
              p.life = elapsed / 0.3; // Faster fade in
            } else {
              p.life = 1 - ((elapsed - 0.3) / (particleDuration - 0.3));
            }
            
            if (p.life > 0 && p.x > -30 && p.x < w + 30 && p.y > -30 && p.y < h + 30) {
              ctx.globalAlpha = p.life * 0.95; // Brighter particles
              ctx.fillStyle = "rgba(255, 255, 255, 1.0)";
              
              if (p.type === 0) {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle);
                // Add glow to squares
                ctx.shadowBlur = 6;
                ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                ctx.restore();
              } else {
                ctx.strokeStyle = "rgba(255, 255, 255, 1.0)";
                ctx.lineWidth = p.size * 0.7; // Thicker lines
                ctx.lineCap = "round";
                ctx.shadowBlur = 4;
                ctx.shadowColor = "rgba(255, 255, 255, 0.6)";
                ctx.beginPath();
                ctx.moveTo(p.x - p.vx * 5, p.y - p.vy * 5); // Longer trails
                ctx.lineTo(p.x, p.y);
                ctx.stroke();
              }
            }
          }
          
          ctx.restore();
          
          comp.particles.parts = comp.particles.parts.filter(p => {
            const alive = p.life > 0 && p.x > -50 && p.x < w + 50 && p.y > -50 && p.y < h + 50;
            if (!alive) releaseParticle(p);
            return alive;
          });
        } else {
          comp.particles.parts.forEach(p => releaseParticle(p));
          comp.particles = null;
        }
      }
      
      if (!comp.iris && !comp.shards && !comp.particles) {
        fx.completion = null;
      }
    }

    // Rainbow sweep line effect (visual-only)
    if (fx.rainbow) {
      fx.rainbow.t += dt;
      const speed = 1.4 + 1.6 * fx.rainbow.strength;
      const p = (fx.rainbow.t * speed) % 1;
      const xCenter = fx.rainbow.dir === 1 ? (p*w) : ((1-p)*w);

      const grad = ctx.createLinearGradient(xCenter - 220, 0, xCenter + 220, 0);
      for (let i=0;i<=6;i++){
        grad.addColorStop(i/6, `hsla(${(i*60 + fx.rainbow.t*260)%360}, 95%, 62%, ${0.58*fx.rainbow.strength})`);
      }
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.lineCap = "round";
      ctx.lineWidth = 14;
      ctx.strokeStyle = grad;
      ctx.shadowColor = "rgba(255,255,255,0.25)";
      ctx.shadowBlur = 14;
      ctx.beginPath();
      ctx.moveTo(-20, fx.rainbow.y);
      ctx.lineTo(w+20, fx.rainbow.y);
      ctx.stroke();
      ctx.restore();

      // fade out automatically
      if (fx.rainbow.t > 0.65) fx.rainbow = null;
    }

    // Burst particles
    if (fx.burst) {
      const parts = fx.burst.parts;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      for (const pt of parts) {
        pt.x += pt.vx;
        pt.y += pt.vy;
        pt.vx *= 0.93;
        pt.vy *= 0.93;
        pt.life -= 0.020;

        if (pt.life > 0) {
          ctx.fillStyle = `hsla(${pt.hue}, 95%, 62%, ${Math.max(0, pt.life)})`;
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
      fx.burst.parts = parts.filter(p => p.life > 0);
      if (fx.burst.parts.length === 0) fx.burst = null;
    }

    // Rain
    if (fx.rain) {
      const parts = fx.rain.parts;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      for (const p of parts) {
        p.y += p.vy;
        p.vy *= 1.01;
        p.life -= 0.010;

        if (p.life > 0) {
          ctx.globalAlpha = Math.max(0, p.life);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
      fx.rain.parts = parts.filter(p => p.life > 0 && p.y < h + 40);
      if (fx.rain.parts.length === 0) fx.rain = null;
    }
  }

  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    draw(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  return {
    extravagantBurst,
    startRainbowSweep,
    startRain,
    triggerCompletionBurst,
  };
}

/* =========================
   REWARD WAVE
========================= */

const rewardWaveEl = document.getElementById("rewardWave");
let rewardArmed = true;

function runRewardWave(){
  // Rainbow flash effect removed
  // Function kept for compatibility but does nothing
}

/* =========================
   EASTER EGG (bottom knob vertical pull ONLY when both right)
========================= */

const couponEl = document.getElementById("coupon");
const couponCodeEl = document.getElementById("couponCode");
const COUPON_CODE = "QUAD50";

function showCoupon(){
  couponCodeEl.textContent = COUPON_CODE;
  couponEl.classList.add("show");
  // auto-hide after a bit
  setTimeout(() => couponEl.classList.remove("show"), 6500);
}

/* =========================
   SLIDER ENGINE
========================= */

function makeSlider(opts){
  const wrap = opts.wrap;
  const knob = opts.knob;
  const glow = opts.glow;

  let value = opts.initial ?? 0;
  let target = value;
  let display = value;

  let isDown = false;
  let pointerId = null;

  let lastDisplay = display;
  let glowLevel = 0;

  let canSlingshot = false;
  let slingshotEdge = null;
  let dragStartTime = 0;

  let lastSettleTime = performance.now();

  // vertical easter egg state (bottom slider only)
  let vPullEnabled = !!opts.verticalEgg;
  let vPulling = false;
  let vStartY = 0;
  let vOffset = 0;

  // Overpull clamp: knob always visible, hard stop holdable
  const OVERPULL_MAX = 0.34; // allow bigger than before but not infinite

  function trackRect(){
    // track area is wrap inner content after padding
    const r = wrap.getBoundingClientRect();
    const cs = getComputedStyle(wrap);
    const pl = parseFloat(cs.paddingLeft) || 0;
    const pr = parseFloat(cs.paddingRight) || 0;
    return { r, pl, pr, w: Math.max(1, r.width - pl - pr) };
  }

  function pxToValue(px){
    const { r, pl, w } = trackRect();
    const x = px - r.left - pl;
    return x / w;
  }

  function setKnobFromDisplay(){
    const { r, pl, w } = trackRect();

    // keep knob visible: clamp visual position to [-OVERPULL_MAX, 1+OVERPULL_MAX]
    const d = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));

    // compute pixel position along track, then clamp within a hard stop range that stays on screen
    // hard stop distance is inside wrap because we have end padding.
    const x = pl + (d * w);
    const xMin = pl + (-OVERPULL_MAX * w);
    const xMax = pl + ((1+OVERPULL_MAX) * w);

    // convert to % of wrap width
    const xClamped = Math.max(xMin, Math.min(xMax, x));
    const pct = (xClamped / r.width) * 100;

    knob.style.left = pct + "%";
    knob.style.top = "50%";
    knob.style.transform = `translate(-50%, -50%)${knob.classList.contains("isDown") ? " scale(var(--knobPress))" : ""}`;

    knob.setAttribute("aria-valuenow", String(Math.max(0, Math.min(1, value))));
  }

  function rubber(v){
    // keep rubber subtle; beyond ends compress
    if (v < 0) return v * 0.42;
    if (v > 1) return 1 + (v - 1) * 0.42;
    return v;
  }

  function settleSpring(to){
    const from = display;
    const start = performance.now();
    const dur = 260;

    function easeOutBack(t){
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    }

    function tick(now){
      const t = Math.min(1, (now - start) / dur);
      const eased = easeOutBack(t);
      display = from + (to - from) * eased;
      display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
      setKnobFromDisplay();
      if (t < 1) requestAnimationFrame(tick);
      else {
        display = to;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
      }
    }
    requestAnimationFrame(tick);
  }

  function pulledAmount(){
    const d = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
    if (slingshotEdge === "left")  return Math.max(0, -d);
    if (slingshotEdge === "right") return Math.max(0, d - 1);
    return 0;
  }

  function maybeSlingshotRelease(){
    if (!canSlingshot || !slingshotEdge) return false;

    const pulled = pulledAmount();
    const dt = performance.now() - dragStartTime;

    // Mobile: much easier to trigger.
    const PULL_THRESHOLD = 0.030;
    const TOO_SLOW_MS = 1800;

    if (pulled < PULL_THRESHOLD) return false;
    if (dt > TOO_SLOW_MS) return false;

    const strength = Math.min(1.0, pulled / 0.12);
    const dest = (slingshotEdge === "left") ? 1 : 0;
    const dir = (dest === 1) ? 1 : -1;

    opts.onSlingshot?.({ strength, dir, wrap, knob });

    const from = display;
    const start = performance.now();
    const dur = 235 - (strength * 55);

    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    function tick(now){
      const t = Math.min(1, (now - start) / dur);
      const k = easeOutCubic(t);

      const overshoot = 0.12 + 0.14 * strength;
      const overshotDest = (dest === 1) ? (1 + overshoot) : (0 - overshoot);

      if (t < 0.78){
        display = from + (overshotDest - from) * (k / 0.78);
      } else {
        const t2 = (t - 0.78) / 0.22;
        display = overshotDest + (dest - overshotDest) * (1 - Math.pow(1 - t2, 2));
      }

      display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
      setKnobFromDisplay();

      if (t < 1) requestAnimationFrame(tick);
      else {
        value = dest;
        target = dest;
        display = dest;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
        opts.onChange?.(value);
        opts.onSlingshotLand?.({ strength, dest, wrap, knob });
      }
    }
    requestAnimationFrame(tick);

    return true;
  }

  function isStationaryOnEdge(){
    const sinceSettle = performance.now() - lastSettleTime;
    const atLeft = value <= 0.0001;
    const atRight = value >= 0.9999;
    return { ok: (sinceSettle > 180) && (atLeft || atRight), atLeft, atRight };
  }

  async function gestureStartAudio(){
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1039',message:'gestureStartAudio entry',data:{ctxState:audio.ctx?.state,started:audio.started,playing:audio.playing},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    // improves iOS reliability: try resume on any pointerdown
    try {
      await initAudio();
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1043',message:'before resume',data:{ctxState:audio.ctx?.state},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      await audio.ctx.resume();
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1046',message:'after resume',data:{ctxState:audio.ctx?.state,started:audio.started},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      // If context is running and we have started audio, we're playing
      if (audio.ctx && audio.ctx.state === 'running' && audio.started) {
        audio.playing = true;
        updatePlayButton();
        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1049',message:'synced playing state',data:{playing:audio.playing},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
      }
    } catch (err) {
      // #region agent log
      fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1051',message:'gestureStartAudio error',data:{error:err.message},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
    }
  }

  function onDown(e){
    if (isDown) return;
    e.preventDefault();

    // iOS audio: attempt resume on gesture
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1057',message:'onDown calling gestureStartAudio (not awaited)',data:{pointerId:e.pointerId},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    gestureStartAudio();

    isDown = true;
    pointerId = e.pointerId;
    wrap.setPointerCapture(pointerId);
    knob.classList.add("isDown");

    // Determine if slingshot can arm (edge + settled)
    const edge = isStationaryOnEdge();
    canSlingshot = edge.ok;
    slingshotEdge = edge.atLeft ? "left" : (edge.atRight ? "right" : null);
    dragStartTime = performance.now();

    // IMPORTANT FIX:
    // If we're in edge-lock/slingshot mode, only start if they grabbed the knob itself.
    if (canSlingshot && e.target !== knob) {
      // keep it locked, do not yank it off-edge from big hitbox
      isDown = false;
      pointerId = null;
      knob.classList.remove("isDown");
      canSlingshot = false;
      slingshotEdge = null;
      return;
    }

    // Easter egg vertical pull (bottom slider only): only when BOTH sliders right AND bottom at right AND slingshot-armed
    if (vPullEnabled && opts.canEggPull?.() && slingshotEdge === "right") {
      vPulling = true;
      vStartY = e.clientY;
      vOffset = 0;
    }

    const v = pxToValue(e.clientX);

    if (canSlingshot && slingshotEdge === "left") {
      target = (v < 0) ? rubber(v) : v;
    } else if (canSlingshot && slingshotEdge === "right") {
      target = (v > 1) ? rubber(v) : v;
    } else {
      target = v;
    }
  }

  function onMove(e){
    if (!isDown || e.pointerId !== pointerId) return;
    e.preventDefault();

    // Easter egg vertical pull tracking
    if (vPullEnabled && vPulling) {
      const dy = e.clientY - vStartY;
      // allow pulling DOWN only
      vOffset = Math.max(0, Math.min(140, dy));
      // visual: move knob down while staying on right edge
      knob.style.top = `calc(50% + ${vOffset}px)`;
      return;
    }

    const v = pxToValue(e.clientX);

    if (canSlingshot && slingshotEdge === "left") {
      target = (v < 0) ? rubber(v) : v;
    } else if (canSlingshot && slingshotEdge === "right") {
      target = (v > 1) ? rubber(v) : v;
    } else {
      target = v;
    }
    
    // Update audio mix immediately during dragging for real-time feedback
    const clampedTarget = Math.max(0, Math.min(1, target));
    if (opts.onChange) {
      opts.onChange(clampedTarget);
    }
  }

  function onUp(e){
    if (!isDown || e.pointerId !== pointerId) return;
    e.preventDefault();

    isDown = false;
    knob.classList.remove("isDown");

    // Ensure first interaction starts audio (mobile)
    opts.onFirstInteract?.();

    // Easter egg release
    if (vPullEnabled && vPulling) {
      const fired = vOffset >= 48; // threshold
      vPulling = false;

      // reset knob Y visually before any further animations
      knob.style.top = "50%";

      if (fired) {
        opts.onEggFire?.({ wrap, knob });
        // keep bottom slider at right (do not change slider mechanics)
        value = 1;
        target = 1;
        display = 1;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
        opts.onChange?.(1);
        return;
      }

      // If not fired, continue with normal slingshot/snap behavior
    }

    if (maybeSlingshotRelease()) {
      canSlingshot = false;
      slingshotEdge = null;
      return;
    }

    const snapDist = opts.snapDist ?? 0.10;
    const dL = Math.abs(display - 0);
    const dR = Math.abs(display - 1);

    let dest = null;
    if (dL < snapDist) dest = 0;
    if (dR < snapDist) dest = 1;

    if (dest === null) {
      value = Math.max(0, Math.min(1, display));
      target = value;
      settleSpring(value);
      opts.onChange?.(value);
    } else {
      value = dest;
      target = dest;
      settleSpring(dest);
      opts.onChange?.(dest);
    }

    canSlingshot = false;
    slingshotEdge = null;
  }

  function animate(){
    // 20% less drag (more responsive): increase follow factor
    const follow = isDown ? 0.316 : 0.259;
    const prevDisplay = display;
    display = display + (target - display) * follow;

    display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
    setKnobFromDisplay();
    
    // Update audio mix during dragging if display changed significantly
    // This ensures smooth audio crossfading while dragging
    if (isDown && Math.abs(display - prevDisplay) > 0.001 && opts.onChange) {
      const clampedDisplay = Math.max(0, Math.min(1, display));
      opts.onChange(clampedDisplay);
    }

    // speed-based glow: brightness depends on motion speed
    const v = Math.abs(display - lastDisplay) / (16.7 / 1000);
    lastDisplay = display;

    const speed = Math.min(1.0, v / 2.4);
    glowLevel = Math.max(glowLevel * 0.90, speed);

    // fade behavior: slower if moving slowly, brighter if moving fast
    const opacity = Math.min(0.98, (glowLevel * 0.92));
    glow.style.opacity = String(isDown ? opacity : opacity * 0.55);

    if (!isDown) {
      glowLevel *= 0.86;
      glow.style.opacity = String(Math.max(0, (glowLevel - 0.08) * 0.9));
    }

    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  wrap.addEventListener("pointerdown", onDown, { passive: false });
  window.addEventListener("pointermove", onMove, { passive: false });
  window.addEventListener("pointerup", onUp, { passive: false });
  window.addEventListener("pointercancel", onUp, { passive: false });

  const sliderAPI = {
    get value(){ return Math.max(0, Math.min(1, value)); },
    set value(v){
      value = Math.max(0, Math.min(1, v));
      target = value;
      display = value;
      setKnobFromDisplay();
      opts.onChange?.(value);
    },
    getDisplayValue: () => Math.max(0, Math.min(1, display))
  };
  
  return sliderAPI;
}

/* =========================
   WIRE UP
========================= */

const panelEl = document.getElementById("panel");
const panelFx = makePanelFx(document.getElementById("panelFx"), panelEl);

const btnPlay = document.getElementById("btnPlay");

let tone = 0;
let blend = 0;

function applyMix(){
  if (!audio.ctx) return;
  setMix(tone, blend);
}

let firstGestureDone = false;

async function onFirstInteract(){
  if (firstGestureDone) return;
  firstGestureDone = true;
  try {
    await play();
    applyMix();
    updatePlayButton();
  } catch (err) {
    console.error(err);
    updatePlayButton();
  }
}

btnPlay.addEventListener("click", async (e) => {
  e.preventDefault();
  try{
    // iOS: click is a safe gesture; force resume
    await initAudio();
    await audio.ctx.resume();

    if (!audio.started) {
      await play();
      applyMix();
      updatePlayButton();
      return;
    }
    if (audio.playing) {
      await pause();
    } else {
      await play();
    }
    updatePlayButton();
  } catch (err){
    console.error(err);
    updatePlayButton();
  }
}, { passive:false });

// Spacebar Play/Pause
window.addEventListener("keydown", async (e) => {
  if (e.code !== "Space") return;
  e.preventDefault();
  try{
    await initAudio();
    await audio.ctx.resume();
    if (!audio.started) {
      await play();
      applyMix();
      updatePlayButton();
      return;
    }
    if (audio.playing) {
      await pause();
    } else {
      await play();
    }
    updatePlayButton();
  } catch {
    updatePlayButton();
  }
}, { passive:false });

function bothRight(){
  return (tone >= 0.999) && (blend >= 0.999);
}

let lastBothRight = false;

function checkReward(){
  const nowBoth = bothRight();
  if (nowBoth && !lastBothRight) {
    runRewardWave();
  }
  lastBothRight = nowBoth;
}

/* =========================
   COMPLETION BURST TRACKING
========================= */

let completionBurstState = {
  toneMet: false,
  blendMet: false,
  toneMetTime: 0,
  blendMetTime: 0,
  cooldownUntil: 0
};

const COMPLETION_THRESHOLD = 0.985;
const COMPLETION_HOLD_TIME = 120; // ms
const COMPLETION_COOLDOWN = 2500; // ms
const COMPLETION_RESET_THRESHOLD = 0.95;

function checkCompletionBurst() {
  // Only check if sliders exist
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1348',message:'checkCompletionBurst entry',data:{sliderToneExists:!!sliderTone,sliderBlendExists:!!sliderBlend},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  if (!sliderTone || !sliderBlend) return;
  
  const now = performance.now();
  // Use display values for continuous checking during dragging
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1354',message:'calling getDisplayValue',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  const toneDisplay = sliderTone.getDisplayValue();
  const blendDisplay = sliderBlend.getDisplayValue();
  const toneMet = toneDisplay >= COMPLETION_THRESHOLD;
  const blendMet = blendDisplay >= COMPLETION_THRESHOLD;
  
  // Track when each slider reaches threshold
  if (toneMet && !completionBurstState.toneMet) {
    completionBurstState.toneMet = true;
    completionBurstState.toneMetTime = now;
  } else if (!toneMet) {
    completionBurstState.toneMet = false;
    completionBurstState.toneMetTime = 0;
  }
  
  if (blendMet && !completionBurstState.blendMet) {
    completionBurstState.blendMet = true;
    completionBurstState.blendMetTime = now;
  } else if (!blendMet) {
    completionBurstState.blendMet = false;
    completionBurstState.blendMetTime = 0;
  }
  
  // Check if both have been met for required duration
  const bothMetForDuration = 
    completionBurstState.toneMet && 
    completionBurstState.blendMet &&
    completionBurstState.toneMetTime > 0 &&
    completionBurstState.blendMetTime > 0 &&
    (now - completionBurstState.toneMetTime) >= COMPLETION_HOLD_TIME &&
    (now - completionBurstState.blendMetTime) >= COMPLETION_HOLD_TIME;
  
  // Check cooldown
  const inCooldown = now < completionBurstState.cooldownUntil;
  
  // Reset cooldown if sliders drop below reset threshold
  if (toneDisplay < COMPLETION_RESET_THRESHOLD || blendDisplay < COMPLETION_RESET_THRESHOLD) {
    completionBurstState.cooldownUntil = 0;
  }
  
  // Trigger if conditions met and not in cooldown
  if (bothMetForDuration && !inCooldown) {
    panelFx.triggerCompletionBurst();
    completionBurstState.cooldownUntil = now + COMPLETION_COOLDOWN;
    // Reset tracking to prevent immediate retrigger
    completionBurstState.toneMetTime = 0;
    completionBurstState.blendMetTime = 0;
  }
}

function slingshotFX({ strength, dir, wrap }){
  // Rainbow sweep effect removed
  // Function kept for compatibility but does nothing
}

function slingshotLandFX({ strength, dest, wrap }){
  const wr = wrap.getBoundingClientRect();
  const pr = panelEl.getBoundingClientRect();
  const x = (wr.left - pr.left) + (dest === 1 ? wr.width : 0) + 40;
  const y = (wr.top - pr.top) + (wr.height / 2) + 40;
  panelFx.extravagantBurst(x, y, strength);
}

function eggPullAllowed(){
  // ONLY when both sliders right
  return bothRight();
}

function eggFire({ wrap, knob }){
  // "slingshot upwards into the top of the screen" + raining white dots + coupon popup
  // animate knob upward (visual only), then restore
  knob.style.transition = "transform 420ms cubic-bezier(.2,1.2,.2,1), top 420ms cubic-bezier(.2,1.2,.2,1)";
  knob.style.transform = "translate(-50%, -50%) scale(1.0) translateY(-340px)";
  setTimeout(() => {
    knob.style.transition = "";
    knob.style.transform = "translate(-50%, -50%)";
  }, 460);

  // Start rain + big burst at top
  panelFx.startRain();
  const pr = panelEl.getBoundingClientRect();
  panelFx.extravagantBurst(pr.width * 0.5 + 40, 20, 1.0);

  showCoupon();
}

const sliderTone = makeSlider({
  wrap: document.getElementById("wrapTone"),
  knob: document.getElementById("knobTone"),
  glow: document.getElementById("glowTone"),
  initial: 0,
  snapDist: 0.10,
  onFirstInteract,
  onSlingshot: slingshotFX,
  onSlingshotLand: slingshotLandFX,
  onChange: (v) => {
    tone = v;
    if (audio.started) applyMix();
    checkReward();
  }
});

const sliderBlend = makeSlider({
  wrap: document.getElementById("wrapBlend"),
  knob: document.getElementById("knobBlend"),
  glow: document.getElementById("glowBlend"),
  initial: 0,
  snapDist: 0.10,
  onFirstInteract,
  onSlingshot: slingshotFX,
  onSlingshotLand: slingshotLandFX,

  verticalEgg: true,
  canEggPull: eggPullAllowed,
  onEggFire: eggFire,

  onChange: (v) => {
    blend = v;
    if (audio.started) applyMix();
    checkReward();
  }
});

tone = sliderTone.value;
blend = sliderBlend.value;

// Continuous check for completion burst (runs every frame after sliders are created)
function completionBurstLoop() {
  // #region agent log
  fetch('http://127.0.0.1:7242/ingest/c39bbad8-fc29-47b4-b1ec-af2b6f554a6d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:1483',message:'completionBurstLoop iteration',data:{sliderToneExists:!!sliderTone,sliderBlendExists:!!sliderBlend},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
  // #endregion
  checkCompletionBurst();
  requestAnimationFrame(completionBurstLoop);
}
requestAnimationFrame(completionBurstLoop);

document.addEventListener("touchmove", (e) => {
  // prevent page scroll inside embed while interacting
  if (firstGestureDone) e.preventDefault();
}, { passive:false });

updatePlayButton();
</script>
</body>
</html>