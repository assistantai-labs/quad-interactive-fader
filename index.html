

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Quad808 — Quad Interactive Mix Fader</title>

  <style>
    @font-face {
      font-family: "VCR OSD Mono";
      src: url("assets/fonts/VCR_OSD_MONO_1.001.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: transparent;
      overscroll-behavior: none;
    }

    body {
      -webkit-text-size-adjust: 100%;
      font-family: "VCR OSD Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }

    .stage {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px 16px 40px;
      box-sizing: border-box;
      background: transparent;
      position: relative;
    }

    .profileBadge {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
      z-index: 10;
      pointer-events: none;
      opacity: 0;
      transition: opacity 200ms ease-in;
    }
    
    .profileBadge.visible {
      opacity: 1;
    }
    
    .profileAvatar {
      width: clamp(144px, 19.5vw, 192px);
      height: clamp(144px, 19.5vw, 192px);
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.15);
      box-shadow: 0 8px 24px rgba(0,0,0,0.4), 0 0 16px rgba(255,255,255,0.1);
      object-fit: cover;
      display: block;
    }
    
    .profileLabel {
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 999px;
      padding: 6px 18px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      text-align: center;
      color: rgba(255,255,255,0.9);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      white-space: nowrap;
      margin-top: -20px;
      position: relative;
      z-index: 11;
    }
    
    .profileLabelLine {
      display: block;
      line-height: 0.8;
    }
    
    .profileLabelLine:first-child {
      font-size: clamp(9px, 1.1vw, 11px);
      margin-bottom: -4px;
    }
    
    .profileLabelLine:last-child {
      font-size: clamp(14px, 1.8vw, 18px);
    }

    .panel {
      width: min(920px, 96vw);
      border-radius: 22px;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 18px 50px rgba(0,0,0,0.55);
      padding: 26px 26px 32px;
      box-sizing: border-box;
      color: #fff;
      position: relative;
      overflow: visible; /* allow FX beyond bounds */
    }

    /* Panel-wide FX overlay so explosions never clip */
    .panelFx {
      position: absolute;
      inset: -40px;            /* extra room so particles can fly */
      pointer-events: none;
      z-index: 3;              /* above labels so nothing clips it */
    }


    :root{
      --text: clamp(16px, 2.2vw, 22px);
      --label: clamp(14px, 2.0vw, 20px);
      --trackH: 4px;
      --knob: clamp(28px, 4.0vw, 38px);
      --knobPress: 1.40; /* expand 40% on press */
      --rowGap: clamp(14px, 2.2vw, 18px);
      --labelGap: 10px;
      /* Maximize hitbox: extend into gap between sliders, leaving ~1px buffer to prevent overlap */
      /* Gap is rowGap * 1.2, so each slider can extend by ~(gap/2 - 1px) */
      --hitH: calc(clamp(56px, 9.5vw, 74px) + clamp(7.4px, 1.32vw, 9.8px));
      --btnH: clamp(44px, 6vw, 54px);
      --btnW: clamp(120px, 18vw, 170px);

      /* end padding so mobile can still "pull past" without leaving screen */
      --endPad: clamp(18px, 3.2vw, 26px);
    }

    .rows {
      display: grid;
      gap: calc(var(--rowGap) * 1.2);
      position: relative;
      z-index: 2;
    }

    .row {
      display: grid;
      grid-template-rows: auto auto;
      gap: var(--labelGap);
    }

    .labels {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: var(--label);
      letter-spacing: 0.20em;
      text-transform: uppercase;
      color: #fff;
      opacity: 0.98;
      padding: 0 2px;
      pointer-events: none;
      position: relative;
      z-index: 2;
    }

    .trackWrap {
      position: relative;
      height: var(--hitH);
      display: flex;
      align-items: center;
      touch-action: none;
      padding-left: var(--endPad);
      padding-right: var(--endPad);
      box-sizing: border-box;
      overflow: visible;
      z-index: 2;
      cursor: pointer; /* Ensure cursor indicates clickability */
    }

    .track {
      width: 100%;
      height: var(--trackH);
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      position: relative;
      overflow: visible;
      pointer-events: none; /* Allow clicks to pass through to trackWrap */
    }

    .trackGlow {
      position: absolute;
      inset: 0;
      border-radius: 999px;
      background: rgba(255,255,255,0.95);
      opacity: 0;
      filter: blur(0.4px);
      box-shadow: 0 0 14px rgba(255,255,255,0.35);
      pointer-events: none;
      transition: opacity 70ms linear;
    }

    .knob {
      position: absolute;
      left: 0%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: var(--knob);
      height: var(--knob);
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      will-change: transform, left, top, clip-path;
      touch-action: none;
      z-index: 5;
      transition: clip-path 0.05s ease-out;
    }

    .knob.isDown {
      transform: translate(-50%, -50%) scale(var(--knobPress));
      box-shadow: 0 10px 22px rgba(0,0,0,0.42);
    }

    @media (hover:hover){
      .trackWrap { cursor: grab; }
      .trackWrap:active { cursor: grabbing; }
    }

    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      padding-top: 20px;
      position: relative;
      z-index: 2;
    }

    .btn {
      height: var(--btnH);
      width: var(--btnW);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: var(--text);
      letter-spacing: 0.22em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      font-family: inherit;
    }

    .btn:active {
      transform: scale(1.03);
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.28);
    }


    @media (max-width: 520px){
      .panel{
        padding: 18px 16px 16px;
        border-radius: 18px;
      }
      .controls{ padding-top: 14px; }
    }
  </style>
</head>

<body>
  <div class="rewardWave" id="rewardWave"></div>
  <div class="stage">
    <div class="profileBadge" id="profileBadge">
      <img class="profileAvatar" id="profileAvatar" src="assets/IMG_7485.jpeg" alt="" onerror="this.onerror=null; this.parentElement.style.display='none'">
      <div class="profileLabel">
        <span class="profileLabelLine">MIXED BY</span><br>
        <span class="profileLabelLine">QUAD808</span>
      </div>
    </div>
    <div class="panel" id="panel">
      <canvas class="panelFx" id="panelFx"></canvas>


      <div class="rows">
        <div class="row" data-slider="tone">
          <div class="labels">
            <div>RAW</div>
            <div>MIXED</div>
          </div>

          <div class="trackWrap" id="wrapTone" aria-label="Raw Mixed Slider">
            <div class="track">
              <div class="trackGlow" id="glowTone"></div>
            </div>
            <div class="knob" id="knobTone" role="slider" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0"></div>
          </div>
        </div>

        <div class="row" data-slider="blend">
          <div class="labels">
            <div>VOCALS</div>
            <div>BEAT</div>
          </div>

          <div class="trackWrap" id="wrapBlend" aria-label="Vocals Beat Slider">
            <div class="track">
              <div class="trackGlow" id="glowBlend"></div>
            </div>
            <div class="knob" id="knobBlend" role="slider" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0"></div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="btnPlay">PLAY</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   AUDIO
========================= */

const FILES = {
  rawVocals: "assets/audio/RAW_VOCALS.wav",
  quadVocals: "assets/audio/QUAD_VOCALS.wav",
  rawFull: "assets/audio/RAW_VOCALS_BEAT.wav",
  quadFull: "assets/audio/QUAD_VOCALS_BEAT.wav",
};

let audio = {
  ctx: null,
  buffers: {},
  sources: {},
  gains: {},
  started: false,
  playing: false,
  loading: false,
};

async function initAudio() {
  if (audio.ctx) return;
  const Ctx = window.AudioContext || window.webkitAudioContext;
  audio.ctx = new Ctx();
  // iOS: Don't resume here - must be called from user gesture handler
  // Resume will be called from gestureStartAudio() or play button
}

async function loadBuffers() {
  if (audio.loading || Object.keys(audio.buffers).length) return;
  audio.loading = true;
  for (const [key, filename] of Object.entries(FILES)) {
    const res = await fetch(filename, { cache: "no-store" });
    if (!res.ok) throw new Error(`Missing file: ${filename}`);
    const arr = await res.arrayBuffer();
    audio.buffers[key] = await audio.ctx.decodeAudioData(arr);
  }
  audio.loading = false;
}

function buildGraph() {
  // iOS: sources must be started from user gesture, so we start them immediately
  // when this is called (which should be from ensureStarted after resume)
  const make = (name, bufKey) => {
    const src = audio.ctx.createBufferSource();
    src.buffer = audio.buffers[bufKey];
    src.loop = true;
    const gain = audio.ctx.createGain();
    gain.gain.value = 0;
    src.connect(gain).connect(audio.ctx.destination);
    audio.sources[name] = src;
    audio.gains[name] = gain;
  };

  make("rawVocals", "rawVocals");
  make("quadVocals", "quadVocals");
  make("rawFull", "rawFull");
  make("quadFull", "quadFull");

  // Start sources immediately (must be in user gesture context)
  // Use a small offset to ensure context is running
  const t0 = Math.max(audio.ctx.currentTime, audio.ctx.currentTime + 0.01);
  Object.values(audio.sources).forEach(s => {
    try {
      s.start(t0);
    } catch (err) {
      console.warn("Failed to start audio source:", err);
    }
  });
}

function setMix(tone, blend) {
  tone = Math.min(1, Math.max(0, tone));
  blend = Math.min(1, Math.max(0, blend));

  const vocalsLayer = (1 - blend);
  const fullLayer = blend;
  const rawPart = (1 - tone);
  const quadPart = tone;

  const now = audio.ctx ? audio.ctx.currentTime : 0;
  const ramp = 0.03;

  const setGain = (node, value) => {
    node.gain.cancelScheduledValues(now);
    node.gain.setTargetAtTime(value, now, ramp);
  };

  if (!audio.gains.rawVocals) return;

  setGain(audio.gains.rawVocals, vocalsLayer * rawPart);
  setGain(audio.gains.quadVocals, vocalsLayer * quadPart);
  setGain(audio.gains.rawFull, fullLayer   * rawPart);
  setGain(audio.gains.quadFull, fullLayer  * quadPart);
}

async function ensureStarted() {
  if (audio.started) return;
  await initAudio();
  // iOS: Must resume context before starting sources (must be in user gesture)
  if (audio.ctx.state !== 'running') {
    try {
      await audio.ctx.resume();
    } catch (err) {
      console.warn("Audio context resume failed:", err);
      throw err; // Re-throw so caller knows it failed
    }
  }
  await loadBuffers();
  buildGraph();
  audio.started = true;
  audio.playing = true;
  updatePlayButton();
}

async function play() {
  await ensureStarted();
  await audio.ctx.resume();
  audio.playing = true;
  updatePlayButton();
}

async function pause() {
  if (!audio.ctx) return;
  await audio.ctx.suspend();
  audio.playing = false;
  updatePlayButton();
}

function updatePlayButton() {
  const btn = document.getElementById("btnPlay");
  if (!btn) return;
  
  // Sync playing state with context state, but only if context exists and audio has started
  // This ensures button reflects actual state when context is resumed via gestures
  if (audio.ctx && audio.started) {
    const contextRunning = audio.ctx.state === 'running';
    // Only sync if context is running (don't override explicit pause)
    // This handles the case where gestureStartAudio resumes the context
    if (contextRunning) {
      audio.playing = true;
    }
    // If context is suspended, trust our internal state (pause() sets it correctly)
  }
  
  btn.textContent = audio.playing ? "PAUSE" : "PLAY";
}

/* =========================
   PANEL-WIDE FX (not clipped)
========================= */

function makePanelFx(canvas, panelEl) {
  const ctx = canvas.getContext("2d");
  const fx = {
    rain: null,        // {parts:[]}
    burst: null,       // {parts:[]}
    rainbow: null,     // {t, dir, strength, y}
    wave: null,        // {t, x0, y0}
    completion: null,  // {iris: {t}, shards: {t, parts:[]}, particles: {t, parts:[]}}
  };

  // Reusable particle pools to avoid allocations
  const particlePool = [];
  const shardPool = [];
  
  function getParticle() {
    return particlePool.pop() || { x: 0, y: 0, vx: 0, vy: 0, life: 1, size: 0, angle: 0, type: 0 };
  }
  
  function getShard() {
    return shardPool.pop() || { angle: 0, hue: 0 };
  }
  
  function releaseParticle(p) {
    if (particlePool.length < 100) particlePool.push(p);
  }
  
  function releaseShard(s) {
    if (shardPool.length < 50) shardPool.push(s);
  }

  let canvasWidth = 0;
  let canvasHeight = 0;

  function resize() {
    const r = panelEl.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor((r.width + 80) * dpr);
    canvas.height = Math.floor((r.height + 80) * dpr);
    canvas.style.width = (r.width + 80) + "px";
    canvas.style.height = (r.height + 80) + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    canvasWidth = r.width + 80;
    canvasHeight = r.height + 80;
  }

  const ro = new ResizeObserver(resize);
  ro.observe(panelEl);
  resize();

  function extravagantBurst(x, y, strength=1) {
    const n = Math.floor(30 + 50 * strength);
    const parts = fx.burst?.parts || [];
    
    for (let i=0;i<n;i++){
      // Explode in all directions like a firework
      const angle = Math.random() * Math.PI * 2;
      const speed = (2 + Math.random() * 4) * strength;
      
      parts.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1,
        size: 3 + Math.random() * 4,
        hue: 120 + (Math.random() * 30),
        settled: false
      });
    }
    fx.burst = { parts };
  }

  function startRainbowSweep(y, dir, strength) {
    fx.rainbow = { t: 0, dir, strength: Math.min(1, Math.max(0.2, strength)), y };
  }

  function startRain() {
    const parts = [];
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const n = 160;
    for (let i=0;i<n;i++){
      parts.push({
        x: Math.random()*w,
        y: -20 - Math.random()*h*0.25,
        vy: 3.5 + Math.random()*5.5,
        life: 1,
        size: 1.5 + Math.random()*2.2
      });
    }
    fx.rain = { parts };
  }

  function triggerCompletionBurst() {
    // Get actual panel dimensions (iframe boundaries), not extended canvas
    const panelRect = panelEl.getBoundingClientRect();
    const w = panelRect.width;
    const h = panelRect.height;
    const centerX = w / 2;
    const centerY = h / 2;
    
    // Check prefers-reduced-motion
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    // Aurora Bloom effect (Option B) - constrained to iframe
    fx.completion = {
      microFlash: { t: 0, centerX, centerY, w, h },
      aurora: { t: 0, centerX, centerY, w, h },
      sweep: prefersReducedMotion ? null : { t: 0, w, h }
    };
  }

  function draw(dt) {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    
    // Get panel dimensions for iframe-constrained effects
    const panelRect = panelEl.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    // Calculate offset from canvas to panel (accounting for -40px inset)
    const offsetX = panelRect.left - canvasRect.left;
    const offsetY = panelRect.top - canvasRect.top;

    // Aurora Bloom completion effect (Option B) - constrained to iframe
    if (fx.completion) {
      const comp = fx.completion;
      const w = comp.aurora?.w || comp.microFlash?.w || comp.sweep?.w || panelRect.width;
      const h = comp.aurora?.h || comp.microFlash?.h || comp.sweep?.h || panelRect.height;
      const centerX = (comp.aurora?.centerX || comp.microFlash?.centerX || w / 2) + offsetX;
      const centerY = (comp.aurora?.centerY || comp.microFlash?.centerY || h / 2) + offsetY;
      
      // Clip to panel bounds (iframe boundaries)
      ctx.save();
      ctx.beginPath();
      ctx.rect(offsetX, offsetY, w, h);
      ctx.clip();
      
      // Layer 1: Micro flash (0-80ms) - subtle white bloom
      if (comp.microFlash) {
        comp.microFlash.t += dt;
        const flashDuration = 0.08; // 80ms
        if (comp.microFlash.t < flashDuration) {
          const progress = comp.microFlash.t / flashDuration;
          // Quick fade in/out
          const opacity = progress < 0.5 
            ? progress * 2 * 0.4  // Fade in to 40% max
            : (1 - progress) * 2 * 0.4; // Fade out
          
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          const radius = Math.min(w, h) * 0.25 * (1 + progress * 0.5);
          const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
          grad.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.6})`);
          grad.addColorStop(0.6, `rgba(255, 255, 255, ${opacity * 0.3})`);
          grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        } else {
          comp.microFlash = null;
        }
      }
      
      // Layer 2: Aurora bloom (0-900ms) - radial gradient with hue shift
      if (comp.aurora) {
        comp.aurora.t += dt;
        const auroraDuration = 0.9; // 900ms
        if (comp.aurora.t < auroraDuration) {
          const progress = comp.aurora.t / auroraDuration;
          // Ease-out expansion
          const eased = 1 - Math.pow(1 - progress, 2.5);
          
          // Hue shift: cool cyan/blue (180-200) → violet (280-300)
          const hueStart = 190;
          const hueEnd = 290;
          const currentHue = hueStart + (hueEnd - hueStart) * progress;
          
          // Opacity fade
          const opacity = (1 - progress) * 0.35; // Max 35% opacity, fades out
          
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          const maxRadius = Math.min(w, h) * 0.4;
          const radius = maxRadius * (0.3 + eased * 0.7); // Expand from 30% to 100%
          
          // Radial gradient with hue shift
          const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
          grad.addColorStop(0, `hsla(${currentHue}, 75%, 70%, ${opacity * 0.8})`);
          grad.addColorStop(0.4, `hsla(${currentHue}, 70%, 65%, ${opacity * 0.6})`);
          grad.addColorStop(0.7, `hsla(${currentHue + 20}, 65%, 60%, ${opacity * 0.4})`);
          grad.addColorStop(1, `hsla(${currentHue + 40}, 60%, 55%, 0)`);
          
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        } else {
          comp.aurora = null;
        }
      }
      
      // Layer 3: Sweep wave (150-700ms) - diagonal wave left→right
      if (comp.sweep) {
        comp.sweep.t += dt;
        const sweepStart = 0.15; // 150ms delay
        const sweepDuration = 0.7; // 700ms total (ends at 850ms)
        const sweepEnd = sweepStart + sweepDuration;
        
        if (comp.sweep.t >= sweepStart && comp.sweep.t < sweepEnd) {
          const sweepProgress = (comp.sweep.t - sweepStart) / sweepDuration;
          // Ease-out
          const eased = 1 - Math.pow(1 - sweepProgress, 2);
          
          // Wave position: travels from left to right (relative to panel)
          const waveX = offsetX - w * 0.2 + (w * 1.4) * eased;
          const waveCenterY = offsetY + h / 2;
          
          // Opacity: fade in then out
          let opacity = 1;
          if (sweepProgress < 0.2) {
            opacity = sweepProgress / 0.2; // Fade in
          } else if (sweepProgress > 0.7) {
            opacity = (1 - sweepProgress) / 0.3; // Fade out
          }
          
          ctx.save();
          ctx.globalCompositeOperation = "screen";
          
          // Diagonal gradient wave (like light through fog)
          const waveWidth = w * 0.4;
          const grad = ctx.createLinearGradient(
            waveX - waveWidth, waveCenterY - h * 0.6,
            waveX + waveWidth, waveCenterY + h * 0.6
          );
          grad.addColorStop(0, `rgba(255, 255, 255, 0)`);
          grad.addColorStop(0.3, `rgba(200, 220, 255, ${opacity * 0.25})`);
          grad.addColorStop(0.5, `rgba(255, 255, 255, ${opacity * 0.35})`);
          grad.addColorStop(0.7, `rgba(240, 200, 255, ${opacity * 0.25})`);
          grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
          
          ctx.fillStyle = grad;
          ctx.globalAlpha = opacity;
          ctx.fillRect(offsetX, offsetY, w, h);
          ctx.restore();
        } else if (comp.sweep.t >= sweepEnd) {
          comp.sweep = null;
        }
      }
      
      ctx.restore(); // Restore clip
      
      // Clean up when all layers are done
      if (!comp.microFlash && !comp.aurora && !comp.sweep) {
        fx.completion = null;
      }
    }

    // Rainbow sweep line effect (visual-only)
    if (fx.rainbow) {
      fx.rainbow.t += dt;
      const speed = 1.4 + 1.6 * fx.rainbow.strength;
      const p = (fx.rainbow.t * speed) % 1;
      const xCenter = fx.rainbow.dir === 1 ? (p*w) : ((1-p)*w);

      const grad = ctx.createLinearGradient(xCenter - 220, 0, xCenter + 220, 0);
      for (let i=0;i<=6;i++){
        grad.addColorStop(i/6, `hsla(${(i*60 + fx.rainbow.t*260)%360}, 95%, 62%, ${0.58*fx.rainbow.strength})`);
      }
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.lineCap = "round";
      ctx.lineWidth = 14;
      ctx.strokeStyle = grad;
      ctx.shadowColor = "rgba(255,255,255,0.25)";
      ctx.shadowBlur = 14;
      ctx.beginPath();
      ctx.moveTo(-20, fx.rainbow.y);
      ctx.lineTo(w+20, fx.rainbow.y);
      ctx.stroke();
      ctx.restore();

      // fade out automatically
      if (fx.rainbow.t > 0.65) fx.rainbow = null;
    }

    // Firework particles that fall to bottom
    if (fx.burst) {
      const parts = fx.burst.parts;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      // Get panel dimensions (iframe boundaries) - exact frame dimensions
      const panelRect = panelEl.getBoundingClientRect();
      const panelW = panelRect.width;
      const panelH = panelRect.height;
      const canvasOffset = 40; // Canvas has 40px inset
      const borderRadius = 22; // Match panel border-radius
      // Use exact frame bottom - no margin
      const bottomY = panelH + canvasOffset; // Exact bottom of iframe
      const leftBound = canvasOffset;
      const rightBound = panelW + canvasOffset;
      
      // Helper function to check if particle is within rounded corner bounds
      function isWithinRoundedBounds(x, y) {
        const relX = x - canvasOffset;
        const relY = y - canvasOffset;
        const cornerRadius = borderRadius;
        
        // Check bottom-left corner
        if (relX < cornerRadius && relY > panelH - cornerRadius) {
          const dx = relX - cornerRadius;
          const dy = relY - (panelH - cornerRadius);
          return (dx * dx + dy * dy) <= (cornerRadius * cornerRadius);
        }
        // Check bottom-right corner
        if (relX > panelW - cornerRadius && relY > panelH - cornerRadius) {
          const dx = relX - (panelW - cornerRadius);
          const dy = relY - (panelH - cornerRadius);
          return (dx * dx + dy * dy) <= (cornerRadius * cornerRadius);
        }
        // Within rectangular bounds
        return relX >= 0 && relX <= panelW && relY >= 0 && relY <= panelH;
      }
      
      for (const pt of parts) {
        if (pt.settled) {
          // Check if settled particle gets disturbed (e.g., by other particles bouncing)
          // Allow settled particles to become active again if they move
          if (Math.abs(pt.vx) > 0.01 || Math.abs(pt.vy) > 0.01) {
            pt.settled = false;
          } else {
            // Particle has settled at bottom, just draw it
            ctx.fillStyle = `hsla(${pt.hue}, 95%, 62%, 0.8)`;
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI*2);
            ctx.fill();
            continue;
          }
        }
        
        // Apply gravity (always pulling down)
        pt.vy += 0.15; // Gravity acceleration
        pt.vx *= 0.99; // Less horizontal friction for more bounce
        
        // Update position
        pt.x += pt.vx;
        pt.y += pt.vy;
        
        // Helper function to check if point is inside rounded rectangle (accounting for particle size)
        function isInsideRoundedRect(x, y, size) {
          const relX = x - canvasOffset;
          const relY = y - canvasOffset;
          const r = borderRadius;
          const margin = size + 1.5; // Increased margin to keep particles further inside
          
          // Check if outside basic rectangle bounds (with margin)
          if (relX < margin || relX > panelW - margin || relY < margin || relY > panelH - margin) {
            return false;
          }
          
          // Check bottom-left corner
          if (relX < r && relY > panelH - r) {
            const cornerX = r;
            const cornerY = panelH - r;
            const dx = relX - cornerX;
            const dy = relY - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist <= (r - margin);
          }
          
          // Check bottom-right corner
          if (relX > panelW - r && relY > panelH - r) {
            const cornerX = panelW - r;
            const cornerY = panelH - r;
            const dx = relX - cornerX;
            const dy = relY - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist <= (r - margin);
          }
          
          // Check top-left corner
          if (relX < r && relY < r) {
            const cornerX = r;
            const cornerY = r;
            const dx = relX - cornerX;
            const dy = relY - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist <= (r - margin);
          }
          
          // Check top-right corner
          if (relX > panelW - r && relY < r) {
            const cornerX = panelW - r;
            const cornerY = r;
            const dx = relX - cornerX;
            const dy = relY - cornerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist <= (r - margin);
          }
          
          // Inside rectangular area (not in corners)
          return true;
        }
        
        // Constrain particle to stay inside rounded rectangle
        const relX = pt.x - canvasOffset;
        const relY = pt.y - canvasOffset;
        const r = borderRadius;
        const margin = pt.size + 1.5; // Increased margin to keep particles further inside
        
        // Check if particle is outside bounds and push it back in
        if (!isInsideRoundedRect(pt.x, pt.y, pt.size)) {
          // Push particle back inside with bouncy response
          if (relX < margin) {
            pt.x = canvasOffset + margin;
            pt.vx *= -0.85; // More bouncy
          } else if (relX > panelW - margin) {
            pt.x = canvasOffset + panelW - margin;
            pt.vx *= -0.85; // More bouncy
          }
          
          if (relY < margin) {
            pt.y = canvasOffset + margin;
            pt.vy *= -0.85; // More bouncy
          } else if (relY > panelH - margin) {
            // Handle bottom edge and corners
            const isInLeftCorner = relX < r;
            const isInRightCorner = relX > panelW - r;
            
            if (isInLeftCorner) {
              // Bottom-left corner - constrain to curve
              const cornerX = canvasOffset + r;
              const cornerY = canvasOffset + panelH - r;
              const dx = pt.x - cornerX;
              const dy = pt.y - cornerY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const maxDist = r - margin;
              if (dist > maxDist) {
                const angle = Math.atan2(dy, dx);
                pt.x = cornerX + Math.cos(angle) * maxDist;
                pt.y = cornerY + Math.sin(angle) * maxDist;
                // Bounce off corner curve
                const normalAngle = angle + Math.PI;
                const bounceSpeed = Math.sqrt(pt.vx * pt.vx + pt.vy * pt.vy) * 0.7;
                pt.vx = Math.cos(normalAngle) * bounceSpeed;
                pt.vy = Math.sin(normalAngle) * bounceSpeed;
              }
            } else if (isInRightCorner) {
              // Bottom-right corner - constrain to curve
              const cornerX = canvasOffset + panelW - r;
              const cornerY = canvasOffset + panelH - r;
              const dx = pt.x - cornerX;
              const dy = pt.y - cornerY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const maxDist = r - margin;
              if (dist > maxDist) {
                const angle = Math.atan2(dy, dx);
                pt.x = cornerX + Math.cos(angle) * maxDist;
                pt.y = cornerY + Math.sin(angle) * maxDist;
                // Bounce off corner curve
                const normalAngle = angle + Math.PI;
                const bounceSpeed = Math.sqrt(pt.vx * pt.vx + pt.vy * pt.vy) * 0.7;
                pt.vx = Math.cos(normalAngle) * bounceSpeed;
                pt.vy = Math.sin(normalAngle) * bounceSpeed;
              }
            } else {
              // Flat bottom edge
              pt.y = canvasOffset + panelH - margin;
            }
          }
        }
        
        // Check if hit bottom - make floor bouncy for all particles
        if (pt.y >= bottomY - pt.size) {
          const isInLeftCorner = relX < r;
          const isInRightCorner = relX > panelW - r;
          
          pt.y = bottomY - pt.size;
          
          // Always bounce off floor unless velocity is extremely low
          if (Math.abs(pt.vy) > 0.05) {
            pt.vy *= -0.85; // Bounce with good energy retention
            pt.vx *= 0.98; // Minimal horizontal friction to keep bouncing
            pt.settled = false; // Never settle while bouncing
          } else {
            // Only settle if velocity is extremely low (almost stopped)
            pt.vy = 0;
            pt.vx = 0;
            pt.settled = true;
          }
        }
        
        // Draw particle
        ctx.fillStyle = `hsla(${pt.hue}, 95%, 62%, 0.9)`;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      
      // Keep all particles (don't remove settled ones)
      // Limit total particles to prevent memory issues
      if (parts.length > 2000) {
        // Remove oldest settled particles if too many
        const settled = parts.filter(p => p.settled);
        if (settled.length > 1000) {
          fx.burst.parts = parts.filter(p => !p.settled || Math.random() > 0.1);
        }
      }
    }

    // Rain
    if (fx.rain) {
      const parts = fx.rain.parts;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      for (const p of parts) {
        p.y += p.vy;
        p.vy *= 1.01;
        p.life -= 0.010;

        if (p.life > 0) {
          ctx.globalAlpha = Math.max(0, p.life);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();
      fx.rain.parts = parts.filter(p => p.life > 0 && p.y < h + 40);
      if (fx.rain.parts.length === 0) fx.rain = null;
    }
  }

  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    draw(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  return {
    extravagantBurst,
    startRainbowSweep,
    startRain,
    triggerCompletionBurst,
  };
}

/* =========================
   REWARD WAVE
========================= */

const rewardWaveEl = document.getElementById("rewardWave");
let rewardArmed = true;

function runRewardWave(){
  // Rainbow flash effect removed
  // Function kept for compatibility but does nothing
}

/* =========================
   EASTER EGG (bottom knob vertical pull ONLY when both right)
========================= */

/* =========================
   SLIDER ENGINE
========================= */

function makeSlider(opts){
  const wrap = opts.wrap;
  const knob = opts.knob;
  const glow = opts.glow;

  let value = opts.initial ?? 0;
  let target = value;
  let display = value;

  let isDown = false;
  let pointerId = null;

  let lastDisplay = display;
  let glowLevel = 0;

  let canSlingshot = false;
  let slingshotEdge = null;
  let dragStartTime = 0;

  let lastSettleTime = performance.now();

  // vertical easter egg state (bottom slider only)
  let vPullEnabled = !!opts.verticalEgg;
  let vPulling = false;
  let vStartY = 0;
  let vStartX = 0;
  let vOffset = 0;

  // Overpull clamp: knob always visible, hard stop holdable
  const OVERPULL_MAX = 0.34; // allow bigger than before but not infinite
  
  // Morph slingshot constants
  const MAX_OVERSCROLL = 0.15; // Maximum overscroll distance (normalized) for morphing
  const STRETCH_THRESHOLD = 0.25; // Minimum stretch to trigger slingshot
  const MORPH_SCALE_X = 0.65; // Horizontal stretch multiplier (more dramatic)
  const MORPH_SCALE_Y = 0.35; // Vertical compression multiplier (more dramatic)
  const MORPH_BULGE_FACTOR = 0.6; // How much the front bulges forward
  
  // Morph state
  let overscroll = 0; // How far beyond endpoint the pointer would be (0-1 normalized)
  let stretch = 0; // Computed stretch amount (0-1)
  let dragDirection = 0; // -1 for left, 1 for right, 0 for none
  let morphShake = 0; // Current shake offset

  function trackRect(){
    // track area is wrap inner content after padding
    const r = wrap.getBoundingClientRect();
    const cs = getComputedStyle(wrap);
    const pl = parseFloat(cs.paddingLeft) || 0;
    const pr = parseFloat(cs.paddingRight) || 0;
    return { r, pl, pr, w: Math.max(1, r.width - pl - pr) };
  }

  function pxToValue(px){
    const { r, pl, w } = trackRect();
    const x = px - r.left - pl;
    return x / w;
  }

  function setKnobFromDisplay(){
    const { r, pl, w } = trackRect();

    // Calculate overscroll for morphing - based on how far display goes beyond 0-1
    if (isDown) {
      const clampedDisplay = Math.max(0, Math.min(1, display));
      const atLeftEdge = clampedDisplay <= 0.001;
      const atRightEdge = clampedDisplay >= 0.999;
      
      // Check if pulling back from edge
      const pullingBack = (atLeftEdge && target > 0.01) || (atRightEdge && target < 0.99);
      
      if (display < 0) {
        overscroll = Math.abs(display);
        dragDirection = -1;
      } else if (display > 1) {
        overscroll = display - 1;
        dragDirection = 1;
      } else if (pullingBack) {
        overscroll = 0;
        dragDirection = 0;
      } else if (atLeftEdge) {
        overscroll = 0.01;
        dragDirection = -1;
      } else if (atRightEdge) {
        overscroll = 0.01;
        dragDirection = 1;
      } else {
        overscroll = 0;
        dragDirection = 0;
      }
      
      stretch = Math.min(1, overscroll / MAX_OVERSCROLL);
      if ((atLeftEdge || atRightEdge) && !pullingBack && stretch < 0.15) {
        stretch = 0.15;
      }
    } else {
      overscroll = 0;
      stretch = 0;
      dragDirection = 0;
    }
    
    // Use original OVERPULL_MAX logic for visual position (allows ball to go slightly past)
    const d = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));

    // compute pixel position along track, then clamp within a hard stop range that stays on screen
    const x = pl + (d * w);
    const xMin = pl + (-OVERPULL_MAX * w);
    const xMax = pl + ((1+OVERPULL_MAX) * w);

    // convert to % of wrap width
    const xClamped = Math.max(xMin, Math.min(xMax, x));
    const pct = (xClamped / r.width) * 100;

    knob.style.left = pct + "%";
    knob.style.top = "50%";
    
    // Apply morphing transforms
    applyMorphTransform();

    knob.setAttribute("aria-valuenow", String(Math.max(0, Math.min(1, value))));
  }
  
  function applyMorphTransform() {
    const isPressed = knob.classList.contains("isDown");
    const baseScale = isPressed ? parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--knobPress')) || 1.4 : 1;
    
    // Calculate morph scales (more dramatic)
    const scaleX = 1 + (MORPH_SCALE_X * stretch);
    const scaleY = 1 - (MORPH_SCALE_Y * stretch);
    
    // Apply shake if stretch is high
    if (stretch > 0.75) {
      const shakeIntensity = (stretch - 0.75) / 0.25;
      morphShake = (Math.random() - 0.5) * 1.2 * shakeIntensity * 0.4; // More dramatic shake
    } else {
      morphShake = 0;
    }
    
    // Build transform string
    let transform = `translate(-50%, -50%)`;
    
    // Apply base press scale
    if (isPressed) {
      transform += ` scale(${baseScale})`;
    }
    
    // Apply morph scaling (after base scale) - more dramatic
    if (stretch > 0) {
      // Rotate to align with drag direction, then scale
      const angle = dragDirection === 1 ? 0 : Math.PI; // 0 for right, 180 for left
      transform += ` rotate(${angle}rad) scale(${scaleX}, ${scaleY}) rotate(${-angle}rad)`;
    }
    
    // Apply shake offset
    if (morphShake !== 0) {
      transform += ` translate(${morphShake}px, 0)`;
    }
    
    knob.style.transform = transform;
    
    // Apply clip-path for dramatic teardrop shape when stretched
    if (stretch > 0.05) {
      const knobSize = parseFloat(getComputedStyle(knob).width) || 28;
      const radius = knobSize / 2;
      const bulge = radius * (1 + stretch * MORPH_BULGE_FACTOR); // More dramatic bulge forward
      const tailCompress = radius * (1 - stretch * 0.3); // Compress back more
      
      if (dragDirection === 1) {
        // Stretching right - bulge points right
        knob.style.clipPath = `ellipse(${bulge}px ${radius * scaleY}px at ${bulge}px 50%)`;
      } else if (dragDirection === -1) {
        // Stretching left - bulge points left
        knob.style.clipPath = `ellipse(${bulge}px ${radius * scaleY}px at ${radius - bulge + radius}px 50%)`;
      }
    } else {
      knob.style.clipPath = "";
    }
  }

  function rubber(v){
    // keep rubber subtle; beyond ends compress
    if (v < 0) return v * 0.42;
    if (v > 1) return 1 + (v - 1) * 0.42;
    return v;
  }

  function settleSpring(to){
    const from = display;
    const start = performance.now();
    const dur = 260;

    function easeOutBack(t){
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    }

    function tick(now){
      const t = Math.min(1, (now - start) / dur);
      const eased = easeOutBack(t);
      display = from + (to - from) * eased;
      display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
      setKnobFromDisplay();
      if (t < 1) requestAnimationFrame(tick);
      else {
        display = to;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
      }
    }
    requestAnimationFrame(tick);
  }

  function pulledAmount(){
    // Use original logic: calculate based on display going beyond 0-1
    const d = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
    if (slingshotEdge === "left")  return Math.max(0, -d);
    if (slingshotEdge === "right") return Math.max(0, d - 1);
    return 0;
  }

  function maybeSlingshotRelease(){
    if (!canSlingshot || !slingshotEdge) return false;

    const pulled = pulledAmount();
    const dt = performance.now() - dragStartTime;

    // Mobile: much easier to trigger.
    const PULL_THRESHOLD = 0.030;
    const TOO_SLOW_MS = 1800;

    if (pulled < PULL_THRESHOLD) return false;
    if (dt > TOO_SLOW_MS) return false;

    const strength = Math.min(1.0, pulled / 0.12);
    const dest = (slingshotEdge === "left") ? 1 : 0;
    const dir = (dest === 1) ? 1 : -1;

    opts.onSlingshot?.({ strength, dir, wrap, knob });

    // Reset morph state before launch
    stretch = 0;
    overscroll = 0;
    dragDirection = 0;

    const from = display;
    const start = performance.now();
    const dur = 235 - (strength * 55);

    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    function tick(now){
      const t = Math.min(1, (now - start) / dur);
      const k = easeOutCubic(t);

      const overshoot = 0.12 + 0.14 * strength;
      const overshotDest = (dest === 1) ? (1 + overshoot) : (0 - overshoot);

      if (t < 0.78){
        display = from + (overshotDest - from) * (k / 0.78);
      } else {
        const t2 = (t - 0.78) / 0.22;
        display = overshotDest + (dest - overshotDest) * (1 - Math.pow(1 - t2, 2));
      }

      display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
      setKnobFromDisplay();

      if (t < 1) requestAnimationFrame(tick);
      else {
        value = dest;
        target = dest;
        display = dest;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
        opts.onChange?.(value);
        opts.onSlingshotLand?.({ strength, dest, wrap, knob });
      }
    }
    requestAnimationFrame(tick);

    return true;
  }

  function isStationaryOnEdge(){
    const sinceSettle = performance.now() - lastSettleTime;
    const atLeft = value <= 0.0001;
    const atRight = value >= 0.9999;
    return { ok: (sinceSettle > 180) && (atLeft || atRight), atLeft, atRight };
  }

  async function gestureStartAudio(){
    // improves iOS reliability: try resume on any pointerdown (user gesture)
    try {
      if (!audio.ctx) {
        await initAudio();
      }
      // iOS: resume must be called from user gesture
      if (audio.ctx && audio.ctx.state !== 'running') {
        await audio.ctx.resume();
      }
      // If not started yet, start audio on first gesture
      if (!audio.started) {
        await ensureStarted();
        applyMix();
      }
      // If context is running and we have started audio, we're playing
      if (audio.ctx && audio.ctx.state === 'running' && audio.started) {
        audio.playing = true;
        updatePlayButton();
      }
    } catch (err) {
      console.warn("gestureStartAudio failed:", err);
    }
  }

  function onDown(e){
    if (isDown) return;
    e.preventDefault();

    // iOS audio: attempt resume on gesture
    gestureStartAudio();

    isDown = true;
    pointerId = e.pointerId;
    wrap.setPointerCapture(pointerId);
    knob.classList.add("isDown");

    // Determine if slingshot can arm (edge + settled)
    const edge = isStationaryOnEdge();
    canSlingshot = edge.ok;
    slingshotEdge = edge.atLeft ? "left" : (edge.atRight ? "right" : null);
    dragStartTime = performance.now();

    // IMPORTANT FIX:
    // If we're in edge-lock/slingshot mode, only start if they grabbed the knob itself.
    // For normal interaction, allow clicking anywhere in the trackWrap hitbox
    if (canSlingshot && e.target !== knob) {
      // keep it locked, do not yank it off-edge from big hitbox
      isDown = false;
      pointerId = null;
      knob.classList.remove("isDown");
      canSlingshot = false;
      slingshotEdge = null;
      return;
    }
    
    // Normal interaction: clicking anywhere in trackWrap (including track area) should work
    // The event listener is on wrap, so e.target will be wrap when clicking on empty trackWrap area
    // or knob when clicking on knob, or track (but track has pointer-events: none so it passes through)

    // Easter egg vertical pull (bottom slider only): only when BOTH sliders right AND bottom at right AND slingshot-armed
    if (vPullEnabled && opts.canEggPull?.() && slingshotEdge === "right") {
      vPulling = true;
      vStartY = e.clientY;
      vStartX = e.clientX;
      vOffset = 0;
    }

    const v = pxToValue(e.clientX);
    
    // Allow target to go beyond 0-1 for overscroll calculation
    // Visual position will be clamped in setKnobFromDisplay
    target = v;
  }

  function onMove(e){
    if (!isDown || e.pointerId !== pointerId) return;
    e.preventDefault();

    // Easter egg vertical pull tracking
    if (vPullEnabled && vPulling) {
      const dx = Math.abs(e.clientX - vStartX);
      const dy = e.clientY - vStartY;
      
      // If user moves horizontally significantly, exit vertical pull mode and allow normal slider movement
      if (dx > 15) {
        vPulling = false;
        vOffset = 0;
        knob.style.top = "50%";
        // Continue with normal horizontal movement below
      } else {
        // allow pulling DOWN only
        vOffset = Math.max(0, Math.min(140, dy));
        // visual: move knob down while staying on right edge
        knob.style.top = `calc(50% + ${vOffset}px)`;
        return;
      }
    }

    const v = pxToValue(e.clientX);
    
    // Allow target to go beyond 0-1 for overscroll calculation
    // Visual position will be clamped in setKnobFromDisplay
    target = v;
    
    // Update audio mix immediately during dragging for real-time feedback
    // Use clamped value for audio (0-1 range)
    const clampedTarget = Math.max(0, Math.min(1, target));
    if (opts.onChange) {
      opts.onChange(clampedTarget);
    }
  }

  function onUp(e){
    if (!isDown || e.pointerId !== pointerId) return;
    e.preventDefault();

    isDown = false;
    knob.classList.remove("isDown");

    // Ensure first interaction starts audio (mobile)
    opts.onFirstInteract?.();

    // Easter egg release
    if (vPullEnabled && vPulling) {
      const fired = vOffset >= 48; // threshold
      vPulling = false;

      // reset knob Y visually before any further animations
      knob.style.top = "50%";

      if (fired) {
        opts.onEggFire?.({ wrap, knob });
        // keep bottom slider at right (do not change slider mechanics)
        value = 1;
        target = 1;
        display = 1;
        setKnobFromDisplay();
        lastSettleTime = performance.now();
        opts.onChange?.(1);
        return;
      }

      // If not fired, continue with normal slingshot/snap behavior
    }

    if (maybeSlingshotRelease()) {
      canSlingshot = false;
      slingshotEdge = null;
      return;
    }

    const snapDist = opts.snapDist ?? 0.10;
    const dL = Math.abs(display - 0);
    const dR = Math.abs(display - 1);

    let dest = null;
    if (dL < snapDist) dest = 0;
    if (dR < snapDist) dest = 1;

    if (dest === null) {
      value = Math.max(0, Math.min(1, display));
      target = value;
      settleSpring(value);
      opts.onChange?.(value);
    } else {
      value = dest;
      target = dest;
      settleSpring(dest);
      opts.onChange?.(dest);
    }

    canSlingshot = false;
    slingshotEdge = null;
  }

  function animate(){
    // 20% less drag (more responsive): increase follow factor
    const follow = isDown ? 0.316 : 0.259;
    const prevDisplay = display;
    display = display + (target - display) * follow;

    display = Math.max(-OVERPULL_MAX, Math.min(1+OVERPULL_MAX, display));
    setKnobFromDisplay();
    
    // Update audio mix during dragging if display changed significantly
    // This ensures smooth audio crossfading while dragging
    if (isDown && Math.abs(display - prevDisplay) > 0.001 && opts.onChange) {
      const clampedDisplay = Math.max(0, Math.min(1, display));
      opts.onChange(clampedDisplay);
    }

    // speed-based glow: brightness depends on motion speed
    const v = Math.abs(display - lastDisplay) / (16.7 / 1000);
    lastDisplay = display;

    const speed = Math.min(1.0, v / 2.4);
    glowLevel = Math.max(glowLevel * 0.90, speed);

    // fade behavior: slower if moving slowly, brighter if moving fast
    const opacity = Math.min(0.98, (glowLevel * 0.92));
    glow.style.opacity = String(isDown ? opacity : opacity * 0.55);

    if (!isDown) {
      glowLevel *= 0.86;
      glow.style.opacity = String(Math.max(0, (glowLevel - 0.08) * 0.9));
    }

    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  wrap.addEventListener("pointerdown", onDown, { passive: false });
  window.addEventListener("pointermove", onMove, { passive: false });
  window.addEventListener("pointerup", onUp, { passive: false });
  window.addEventListener("pointercancel", onUp, { passive: false });

  const sliderAPI = {
    get value(){ return Math.max(0, Math.min(1, value)); },
    set value(v){
      value = Math.max(0, Math.min(1, v));
      target = value;
      display = value;
      setKnobFromDisplay();
      opts.onChange?.(value);
    },
    getDisplayValue: () => Math.max(0, Math.min(1, display))
  };
  
  return sliderAPI;
}

/* =========================
   WIRE UP
========================= */

const panelEl = document.getElementById("panel");
const panelFx = makePanelFx(document.getElementById("panelFx"), panelEl);

const btnPlay = document.getElementById("btnPlay");

let tone = 0;
let blend = 0;

function applyMix(){
  if (!audio.ctx) return;
  setMix(tone, blend);
}

let firstGestureDone = false;

async function onFirstInteract(){
  if (firstGestureDone) return;
  firstGestureDone = true;
  try {
    await play();
    applyMix();
    updatePlayButton();
  } catch (err) {
    console.error(err);
    updatePlayButton();
  }
}

btnPlay.addEventListener("click", async (e) => {
  e.preventDefault();
  try{
    // iOS: click is a safe gesture; force resume
    await initAudio();
    await audio.ctx.resume();

    if (!audio.started) {
      await play();
      applyMix();
      updatePlayButton();
      return;
    }
    if (audio.playing) {
      await pause();
    } else {
      await play();
    }
    updatePlayButton();
  } catch (err){
    console.error(err);
    updatePlayButton();
  }
}, { passive:false });

// Spacebar Play/Pause
window.addEventListener("keydown", async (e) => {
  if (e.code !== "Space") return;
  e.preventDefault();
  try{
    await initAudio();
    await audio.ctx.resume();
    if (!audio.started) {
      await play();
      applyMix();
      updatePlayButton();
      return;
    }
    if (audio.playing) {
      await pause();
    } else {
      await play();
    }
    updatePlayButton();
  } catch {
    updatePlayButton();
  }
}, { passive:false });

function bothRight(){
  return (tone >= 0.999) && (blend >= 0.999);
}

let lastBothRight = false;

function checkReward(){
  const nowBoth = bothRight();
  if (nowBoth && !lastBothRight) {
    runRewardWave();
  }
  lastBothRight = nowBoth;
}

/* =========================
   COMPLETION BURST TRACKING
========================= */

let completionBurstState = {
  toneMet: false,
  blendMet: false,
  toneMetTime: 0,
  blendMetTime: 0,
  lastTriggerTime: 0
};

const COMPLETION_THRESHOLD = 0.985;
const COMPLETION_HOLD_TIME = 150; // ms
const COMPLETION_RESET_THRESHOLD = 0.97;

function checkCompletionBurst() {
  // Only check if sliders exist
  if (!sliderTone || !sliderBlend) return;
  
  const now = performance.now();
  // Use display values for continuous checking during dragging (read-only)
  const toneDisplay = sliderTone.getDisplayValue();
  const blendDisplay = sliderBlend.getDisplayValue();
  const toneMet = toneDisplay >= COMPLETION_THRESHOLD;
  const blendMet = blendDisplay >= COMPLETION_THRESHOLD;
  
  // Track when each slider reaches threshold
  if (toneMet && !completionBurstState.toneMet) {
    completionBurstState.toneMet = true;
    completionBurstState.toneMetTime = now;
  } else if (!toneMet) {
    completionBurstState.toneMet = false;
    completionBurstState.toneMetTime = 0;
  }
  
  if (blendMet && !completionBurstState.blendMet) {
    completionBurstState.blendMet = true;
    completionBurstState.blendMetTime = now;
  } else if (!blendMet) {
    completionBurstState.blendMet = false;
    completionBurstState.blendMetTime = 0;
  }
  
  // Check if both have been met for required duration
  const bothMetForDuration = 
    completionBurstState.toneMet && 
    completionBurstState.blendMet &&
    completionBurstState.toneMetTime > 0 &&
    completionBurstState.blendMetTime > 0 &&
    (now - completionBurstState.toneMetTime) >= COMPLETION_HOLD_TIME &&
    (now - completionBurstState.blendMetTime) >= COMPLETION_HOLD_TIME;
  
  // Reset tracking if sliders drop below reset threshold (allows retrigger)
  if (toneDisplay < COMPLETION_RESET_THRESHOLD || blendDisplay < COMPLETION_RESET_THRESHOLD) {
    completionBurstState.toneMet = false;
    completionBurstState.blendMet = false;
    completionBurstState.toneMetTime = 0;
    completionBurstState.blendMetTime = 0;
  }
  
  // Trigger if conditions met (no cooldown - allows repeated triggers)
  // Only prevent immediate retrigger (within 100ms) to avoid spam
  const timeSinceLastTrigger = now - completionBurstState.lastTriggerTime;
  if (bothMetForDuration && timeSinceLastTrigger > 100) {
    panelFx.triggerCompletionBurst();
    completionBurstState.lastTriggerTime = now;
    // Reset tracking to allow retrigger after they move away and come back
    completionBurstState.toneMetTime = 0;
    completionBurstState.blendMetTime = 0;
  }
}

function slingshotFX({ strength, dir, wrap }){
  // Rainbow sweep effect removed
  // Function kept for compatibility but does nothing
}

function slingshotLandFX({ strength, dest, wrap }){
  const wr = wrap.getBoundingClientRect();
  const pr = panelEl.getBoundingClientRect();
  const x = (wr.left - pr.left) + (dest === 1 ? wr.width : 0) + 40;
  const y = (wr.top - pr.top) + (wr.height / 2) + 40;
  panelFx.extravagantBurst(x, y, strength);
}

function eggPullAllowed(){
  // ONLY when both sliders right
  return bothRight();
}

function eggFire({ wrap, knob }){
  // "slingshot upwards into the top of the screen" + raining white dots
  // animate knob upward (visual only), then restore
  knob.style.transition = "transform 420ms cubic-bezier(.2,1.2,.2,1), top 420ms cubic-bezier(.2,1.2,.2,1)";
  knob.style.transform = "translate(-50%, -50%) scale(1.0) translateY(-340px)";
  setTimeout(() => {
    knob.style.transition = "";
    knob.style.transform = "translate(-50%, -50%)";
  }, 460);

  // Start rain + big burst at top
  panelFx.startRain();
  const pr = panelEl.getBoundingClientRect();
  panelFx.extravagantBurst(pr.width * 0.5 + 40, 20, 1.0);
}

const sliderTone = makeSlider({
  wrap: document.getElementById("wrapTone"),
  knob: document.getElementById("knobTone"),
  glow: document.getElementById("glowTone"),
  initial: 0,
  snapDist: 0.10,
  onFirstInteract,
  onSlingshot: slingshotFX,
  onSlingshotLand: slingshotLandFX,
  onChange: (v) => {
    tone = v;
    if (audio.started) applyMix();
    checkReward();
  }
});

const sliderBlend = makeSlider({
  wrap: document.getElementById("wrapBlend"),
  knob: document.getElementById("knobBlend"),
  glow: document.getElementById("glowBlend"),
  initial: 0,
  snapDist: 0.10,
  onFirstInteract,
  onSlingshot: slingshotFX,
  onSlingshotLand: slingshotLandFX,

  verticalEgg: true,
  canEggPull: eggPullAllowed,
  onEggFire: eggFire,

  onChange: (v) => {
    blend = v;
    if (audio.started) applyMix();
    checkReward();
  }
});

tone = sliderTone.value;
blend = sliderBlend.value;

// Continuous check for completion burst (runs every frame after sliders are created)
function completionBurstLoop() {
  checkCompletionBurst();
  requestAnimationFrame(completionBurstLoop);
}
requestAnimationFrame(completionBurstLoop);

document.addEventListener("touchmove", (e) => {
  // prevent page scroll inside embed while interacting
  if (firstGestureDone) e.preventDefault();
}, { passive:false });

updatePlayButton();

// Profile badge: hide if image missing, fade in if loaded
(function(){
  const badge = document.getElementById("profileBadge");
  const avatar = document.getElementById("profileAvatar");
  if (!badge || !avatar) return;
  
  // Check if image loads successfully
  const showBadge = () => {
    badge.classList.add("visible");
  };
  
  const hideBadge = () => {
    badge.style.display = "none";
  };
  
  // Check image load status
  if (avatar.complete) {
    if (avatar.naturalWidth > 0 && avatar.naturalHeight > 0) {
      showBadge();
    } else {
      hideBadge();
    }
  } else {
    avatar.addEventListener("load", showBadge, { once: true });
    avatar.addEventListener("error", hideBadge, { once: true });
    // Also check after a short delay in case onerror fires before this
    setTimeout(() => {
      if (avatar.naturalWidth === 0 && avatar.naturalHeight === 0 && badge.style.display !== "none") {
        hideBadge();
      }
    }, 100);
  }
})();
</script>
</body>
</html>